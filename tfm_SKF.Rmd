---
title: "TFM Caracterización inmunonómica del microambiente tumoral en cáncer colorrectal"
author: "Sheddad Kaid-Salah Ferrón"
date: "`r format(Sys.Date())`"
output:
  html_document:
    code_folding: hide
    toc: true
    toc_float: yes
    toc_depth: 3
    theme: simplex #flatly
    number_sections: true
    csl: vancouver.csl
    css: styles.css # Estilos del html. Para aumentar el tamaño de la letra pej.
  pdf_document:
    toc: yes
params:
  date: !r Sys.Date()
  printcode:
    label: "Display Code:"
    value: TRUE # or set it to FALSE
  data:
    label: "Input dataset:"
    value: data/infoClin_all_dataset.RData
    input: file
  folder.data: ""
  p.train: !r 2/3
  subtitulo: Código de trabajo
  seed: 123571113
nocite: 
bibliography: referencias_tfm.bib
geometry: margin=2cm
---

```{r class.source = 'fold-hide', setup, include=FALSE}
# Parametrizamos
require(knitr)
require(rmdformats)

## Global options
options(max.print="75")
opts_chunk$set(echo=params$printcode,
	             cache=TRUE, # para no reproducir cuando no hay cambios 
               prompt=FALSE,
               tidy=TRUE,
               comment=NA,
               message=FALSE,
               warning=FALSE)
opts_knit$set(width=75)
Sys.setlocale("LC_TIME", "C")
```

``` {r paquetes, include=FALSE}
# Lista de paquetes a comprobar e instalar si es necesario
packages <- c("bibtex", "caret", "dplyr", "factoextra", "ggplot2", "knitr", 
              "patchwork", "randomForest", "rmdformats", "skimr", "sqldf")

# Comprobamos si cada paquete está instalado y los cargamos
for (package in packages) {
  if (!requireNamespace(package, quietly = TRUE)) {
    install.packages(package)
  }
  library(package, character.only = TRUE)
}
```

``` {r funciones, include=FALSE}
# Función para transponer un DataFrames
t_df <- function(df) {
  # Transponemos el dataframe
  df_t <- as.data.frame(t(df))
  
  # Los nombres de las columnas originales se convierten en nombres de filas
  rownames(df_t) <- colnames(df)
  # Los nombres de las filas originales se convierten en nombres de columnas
  colnames(df_t) <- rownames(df)
  
  # Devolvemos el daataframe transpuesto y con los nombres de filas y columnas
  return(df_t)
}

# Función para dibujar todos los boxplots de los datos de MCPcounter
boxplot_MCPcounter <- function(data, x, y, fill, title, p_value=NULL, 
                               xlabel="", ylabel="MCPc score") {
  # Crear el boxplot
  bp <- ggplot(data, aes_string(x = x, y = y, fill = fill)) +
    geom_boxplot() +
    scale_fill_brewer(palette = "Pastel1") + # Opcional: Mejora la paleta de colores
    labs(title = title, x = xlabel, y = ylabel) +
    theme_minimal() +
    # Añadimos el valor de la media a la gráfica
    stat_summary(fun = mean, geom = "text", aes(label = round(..y.., digits = 2))
                 , vjust = -0.5, color = "black") +
    theme(legend.position = "none", # Omitir la leyenda si `grupo` ya es claro por el color
          axis.text.x = element_text(angle = 45, hjust = 1))# Inclinar las etiquetas del eje x
    # Añadimos p_value si se proporciona
    if (!is.null(p_value)) {
      bp <- bp + annotate("text", x = Inf, y = Inf, 
                          label = if (p_value < 0.001) { # notación científica
                                    sprintf("p-value: %.3e", p_value)
                                } else { # tres decimales desechando ceros a la izquierda
                                    sprintf("p-value: %s", 
                                            formatC(p_value, format = "fg", 
                                                    digits = 3, 
                                                    drop0trailing = TRUE))}, 
                          vjust = 0.95, hjust = 1, size = 4, color = "turquoise3")}
  
  # Devolvemos el boxplot
  return(bp)
}
```

-----------------------------------------------------------

# Obtención  y preparación de los datos

Cargamos los arhivos contenidos en "infoClin_all_dataset.RData" y 
"CRC_stageII.RData" con los contenidos clínicos y de CRC.     

```{r chunck_1_1}
# Cargamos el archivo infoClin_all_dataset.RData 16/03/2024
dataClin <- load("data/infoClin_all_dataset.RData")

# Cargamos el archivo CRC_stageII.RData 19/03/2024
#dataCRC <- load("data/CRC_stageII.RData")

# Cargamos el archivo exp_mat.RData 02/04/2024
dataCRC <- load("data/exp_mat.RData")
```

**GSE Files**

- GSE39582 [@GSE39582_marisa2013gene] 421 vs 585
- GSE14333 [@GSE14333_jorissen2009metastasis] 185 vs 290
- GSE13294 [@GSE13294_jorissen2008dna] 121 vs 155
- GSE17536 [@GSE17536_smith2010experimentally] 111 vs 177

**Platform** [GPL570](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GPL570): 
[HG-U133_Plus_2] Affymetrix Human Genome U133 Plus 2.0 Array 
  
Fusionamos los datos en un único dataframe al que le añadimos la columna *grupo*
con los datos *stage* y *msi*.

Factorizamos las variables categóricas y ordenamos por ID tanto los datos 
clínicos como los de la matriz de expresión. 

Creamos un DataFrame para asignar cada ID a su estudio clínico. A cada estudio 
le asignamos un color para poder identificarlo fácilmente en los estudios gráficos.
  
```{r chunck_1_2}
# 11/04/2023
# Función para preparar el data frame con el estudio por ID. También asignaremos 
# un color a cada estudio. Utilizamos el paquete "dplyr"
prepare_df <- function(df, study_name, color) {
  df %>%
    select(ID) %>%
    mutate(study = study_name, color = color)
}

# Lista de estudios con sus colores asociados
studies_info <- list(
  clx = "red",
  GSE39582 = "blue",
  GSE14333 = "green",
  GSE13294 = "orange",
  GSE17536 = "yellow",
  TCGA = "violet"
)

# Creamos una lista de de los estudios utilizando la función prepare_df
df_studies_list <- lapply(names(studies_info), function(x) {
  prepare_df(get(paste0(x, "_infoClin")), x, studies_info[[x]])
})

# Juntamos los df's de la lista se studies en uno solo y lo ordenamos por 'ID'
df_studies <- bind_rows(df_studies_list) %>% arrange(ID)

# Fusionamos y ordenamos todos los datos clínicos generando "df_dataClin"
df_dataClin <- bind_rows(
  lapply(names(studies_info), function(x) get(paste0(x, "_infoClin")))
) %>% arrange(ID)

# Cramos una nueva columna "grupo" a los "df_dataClin" con los datos de msi y stage
df_dataClin$grupo <- with(df_dataClin, paste(stage, msi_imputed, sep = "_"))

# Cramos una nueva columna "cms_stage" a los "df_dataClin" con los datos de cms y stage 19/04/2024
df_dataClin$cms_stage <- with(df_dataClin, ifelse(is.na(cms), NA, paste(stage, cms, sep = "_")))

# Convertimos a factores
df_dataClin <- df_dataClin %>%
  mutate(across(c(msi_imputed, cms, stage, grupo, cms_stage), factor))

# Añadimos la columna "study" a df_dataClin. Al final no añadimos "color"
df_dataClin <- left_join(df_dataClin, select(df_studies, ID, study), by = "ID")
``` 

Pasamos la matriz de expresión a data_frame y la ordenamos por "ID"

```{r chunck_1_3}
# Pasamos la matriz de expresión a data frame 26/03/2024
df_exmat <- as.data.frame(ex)

# Ordenamos la matriz de expresión por nombre de columnas 26/03/2024
df_exmat <- df_exmat[, order(names(df_exmat))]

# Transponemos la matriz de expresión: 22/04/2025
df_exmat_t <- as.data.frame(t(df_exmat))

# Creamos un df con los datos clínicos y los de expresión génica (transpuesta)
df_dataClin_exmat_t <- cbind (df_dataClin, df_exmat_t)
```
  
# Exploración de los datos

Resumen exploratorio de los datos:  

```{r chunck_2_1}
# Hacemos un Summary con el paquete skimr 18/03/2024 
skim(df_dataClin)
```

Estadísticas y cálculos para la generación de los gráficos de datos clínicos:  

```{r chunck_2_2}
# Estadísticas desglosadas 18/03/2024
# Frecuencias
msi_frecuencias <- table(df_dataClin$msi_imputed)
cms_frecuencias <- table(df_dataClin$cms)
stage_frecuencias <- table(df_dataClin$stage)

# Valores NA
na_msi <- sum(is.na(df_dataClin$msi_imputed))
na_cms <- sum(is.na(df_dataClin$cms))
na_stage <- sum(is.na(df_dataClin$stage))

# Contamos cuantos MSI y MSS tenemos por cada estadio, II y III 19/03/2024
sII_MSI <- sum(df_dataClin$msi_imputed == "MSI" & df_dataClin$stage == "II")
sII_MSS <- sum(df_dataClin$msi_imputed == "MSS" & df_dataClin$stage == "II")
sIII_MSI <- sum(df_dataClin$msi_imputed == "MSI" & df_dataClin$stage == "III")
sIII_MSS <- sum(df_dataClin$msi_imputed == "MSS" & df_dataClin$stage == "III")

# Crear un dataframe con estos valores
stage_MSI_MSS_df <- data.frame(
  Stage_MSI_MSS = c("II_MSI", "II_MSS", "III_MSI", "III_MSS"),
  Freq = c(sII_MSI, sII_MSS, sIII_MSI, sIII_MSS)
)

# Contamos cuantos MSI y MSS tenemos por cada estadio, II y III 19/04/2024
sII_CMS1 <- sum(df_dataClin$cms_stage == "II_CMS1", na.rm = TRUE)
sII_CMS2 <- sum(df_dataClin$cms_stage == "II_CMS2", na.rm = TRUE)
sII_CMS3 <- sum(df_dataClin$cms_stage == "II_CMS3", na.rm = TRUE)
sII_CMS4 <- sum(df_dataClin$cms_stage == "II_CMS4", na.rm = TRUE)
sIII_CMS1 <- sum(df_dataClin$cms_stage == "III_CMS1", na.rm = TRUE)
sIII_CMS2 <- sum(df_dataClin$cms_stage == "III_CMS2", na.rm = TRUE)
sIII_CMS3 <- sum(df_dataClin$cms_stage == "III_CMS3", na.rm = TRUE)
sIII_CMS4 <- sum(df_dataClin$cms_stage == "III_CMS4", na.rm = TRUE)

# Crear un dataframe con estos valores
stage_CMS_df <- data.frame(
  Stage_CMS = c("II_CMS1", "II_CMS2", "II_CMS3", "II_CMS4", 
                "III_CMS1", "III_CMS2", "III_CMS3", "III_CMS4"),
  Freq = c(sII_CMS1, sII_CMS2, sII_CMS3, sII_CMS4, 
           sIII_CMS1, sIII_CMS2, sIII_CMS3, sIII_CMS4)
)

```

# Análisis de los datos clínicos {.tabset .tabset-fade .tabset-pills}  

## ESTADIO

```{r chunck_3_1}
# Pasamos a DataFrame stage
df_stage_frecuencias <- as.data.frame(stage_frecuencias)
df_stage_frecuencias

# Añadimos los porcentajes
# Calculamos el total de frecuencias
total_frecuencias <- sum(df_stage_frecuencias$Freq)
# Añadimos una columna de porcentajes al dataframe
df_stage_frecuencias$Porcentaje <- (df_stage_frecuencias$Freq / total_frecuencias) * 100

# Diagrama de Barras de ESTADIO
p1 <- ggplot(df_stage_frecuencias, aes(x = Var1, y = Freq)) +
  geom_bar(stat = "identity", fill = c("salmon", "seashell3")) +
  geom_text(aes(label = Freq), vjust = -0.5, size = 3.5) + # Frecuencias arriba de cada barra
  # Porcentajes en la mitad + o -
  geom_text(aes(label = paste0(round(Porcentaje, 1), "%")), vjust = 5, size = 3.5) +
  labs(title = "STAGE", x = "", y = "Frecuencia") +
  theme_minimal()
p1
```

## MSI/MSS  

```{r chunck_3_2}
# Pasamos a DataFrame msi
df_msi_frecuencias <- as.data.frame(msi_frecuencias)
df_msi_frecuencias

# Añadimos los porcentajes
# Calculamos el total de frecuencias
total_frecuencias <- sum(df_msi_frecuencias$Freq)
# Añadimos una columna de porcentajes al dataframe
df_msi_frecuencias$Porcentaje <- (df_msi_frecuencias$Freq / total_frecuencias) * 100

# Diagrama de Barras de MSI/MSS
p2 <- ggplot(df_msi_frecuencias, aes(x = Var1, y = Freq)) +
  geom_bar(stat = "identity", fill = c("salmon", "seashell3")) +
  geom_text(aes(label = Freq), vjust = -0.5, size = 3.5) + # Frecuencias arriba de cada barra
  # Porcentajes en la mitad + o -
  geom_text(aes(label = paste0(round(Porcentaje, 1), "%")), vjust = 5, size = 3.5) +
  labs(title = "MSI/MSS", x = "", y = "Frecuencia") +
  theme_minimal()
p2
```

## MSI/MSS & ESTADIO

```{r chunck_3_3}
# Stage vs MSI/MSS DataFrame
stage_MSI_MSS_df

# Añadimos los porcentajes
# Calculamos el total de frecuencias
total_frecuencias <- sum(stage_MSI_MSS_df$Freq)
# Añadimos una columna de porcentajes al dataframe
stage_MSI_MSS_df$Porcentaje <- (stage_MSI_MSS_df$Freq / total_frecuencias) * 100

# Diagrama de Barras de Stage vs MSI/MSS
p3 <- ggplot(stage_MSI_MSS_df, aes(x = Stage_MSI_MSS, y = Freq)) +
  geom_bar(stat = "identity", fill = c("salmon", "seashell3",
                                       "turquoise3", "slategray")) +
  geom_text(aes(label = Freq), vjust = -0.5, size = 3.5) + # Frecuencias arriba de cada barra
  # Porcentajes en la mitad + o -
  geom_text(aes(label = paste0(round(Porcentaje, 1), "%")), vjust = 2, size = 3.5) +
  labs(title = "STAGE & MSI/MSS", x = "", y = "Frecuencia") +
  theme_minimal()
 
p3
```
  
## CMS  

```{r chunck_3_4}
# Pasamos a DataFrame cms
df_cms_frecuencias <- as.data.frame(cms_frecuencias)
df_cms_frecuencias

# Añadimos los porcentajes
# Calculamos el total de frecuencias
total_frecuencias <- sum(df_cms_frecuencias$Freq)
# Añadimos una columna de porcentajes al dataframe
df_cms_frecuencias$Porcentaje <- (df_cms_frecuencias$Freq / total_frecuencias) * 100

# Diagrama de Barras de CMS
p4 <- ggplot(df_cms_frecuencias, aes(x = Var1, y = Freq, fill = Var1)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = Freq), vjust = -0.3, size = 3.5) +  # Frecuencias arriba de cada barra
  # Porcentajes en la mitad + o -
  geom_text(aes(label = paste0(round(Porcentaje, 1), "%")), vjust = 5, size = 3.5) +  
  scale_fill_manual(values = c("salmon", "seashell3", "turquoise3", "slategray")) +
  labs(title = "CMS", x = "", y = "Frecuencia") +
  theme_minimal() +
  theme(legend.position = "none") # Omitir la leyenda

p4
```

## CMS & ESTADIO

```{r chunck_3_5}
# Stage vs MSI/MSS DataFrame
stage_CMS_df

# Añadimos los porcentajes
# Calculamos el total de frecuencias
total_frecuencias <- sum(stage_CMS_df$Freq)
# Añadimos una columna de porcentajes al dataframe
stage_CMS_df$Porcentaje <- (stage_CMS_df$Freq / total_frecuencias) * 100

# Diagrama de Barras de Stage vs MSI/MSS
p5 <- ggplot(stage_CMS_df, aes(x = Stage_CMS, y = Freq)) +
  geom_bar(stat = "identity", fill = c("salmon", "seashell3",
                                       "turquoise3", "slategray", 
                                       "salmon", "seashell3",
                                       "turquoise3", "slategray")) +
  geom_text(aes(label = Freq), vjust = -0.5, size = 3.5) + # Frecuencias arriba de cada barra
  # Porcentajes en la mitad + o -
  geom_text(aes(label = paste0(round(Porcentaje, 1), "%")), vjust = 2, size = 3.5) +
  labs(title = "STAGE & CMS", x = "", y = "Frecuencia") +
  theme_minimal() + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1))# Inclinar las etiquetas del eje x
 
p5
```

## TODOS

```{r chunck_3_6, fig.width=9, fig.height=13}
# Múltiple Layout con patchwork
# En un grid 3x2
p2 + p3 + p4 + p5 + p1 + plot_layout(ncol = 2, nrow = 3)
```

# Análisis PCA {.tabset .tabset-fade .tabset-pills}

Para el Análisis de Componentes Principales (PCA), normalizamos y escalamos 
(estandarizamos) la matriz de expresión. En nuestro caso, los datos ya están 
normalizamos (en principio con $log_2$) por lo que tan solo los escalamos.  
La estandarización se realiza restando la media de cada variable y 
dividiendo el resultado por la desviación estándar de esa variable.   

$$  
Z = \frac{x-\mu}{\sigma}
$$ 
Utilizamos la función `scale` para escalar. A continuación realizamos el PCA 
con la transpuesta de la matriz de expresión dado que queremos un análisis de 
las muestras en función de los genes y no al revés.   
**IMP**: al hacer el escalado antes de la transposición estamos estandarizando
por genes y no por muestras.  

```{r chunck PCA_0, fig.width=8, fig.height=8,}
# Escalamos/normalizamos la matriz de expresión. También centra. 28/04/2024
# Al hacer el escalado antes de la transposición estamos escalando por genes y 
# no por muestras.
df_exmat_scaled <- scale(df_exmat)
# Hacemos el PCA. Hay que hacer la transpuesta de la matriz de expresión 
# (las columnas representan genes y las filas representen muestras), así los 
# componentes principales reflejan la variabilidad entre muestras. 28/04/2024
# Na haría falta center = TRUE ya que al escalar ya centralizamos.
pca_result <- prcomp(t(df_exmat_scaled), center = TRUE, scale. = FALSE)
```

**RESUMEN PCA**

```{r chunck PCA_0_1, fig.width=8, fig.height=8,}
# Obtenemos los valores propios (la varianza explicada por cada componente)
varianza <- pca_result$sdev^2

# Calculamos la proporción de varianza explicada por cada componente
prop_varianza <- varianza / sum(varianza)

# Calculamos la proporción acumulativa de varianza explicada
prop_acumulada <- cumsum(prop_varianza)

# Crear un dataframe con esta información para las primeras 10 PC
resumen_pca <- data.frame(
  SD = pca_result$sdev[1:10],
  Varianza = prop_varianza[1:10],
  VarAcumulada = prop_acumulada[1:10]
)

print(resumen_pca)
```

La baja varianza explicada por los primeros dos componentes, PC1 (8,2%) y PC2 
(5.4%), sugiere que los datos tienen una distribución de varianza muy dispersa y 
que no hay unas pocas direcciones principales de variabilidad que dominen.  
Esto es coherente con el hecho de que estamos tratando con datos biológicos, en 
concreto de CRC, que suelen ser de alta dimensionalidad con múltiples factores 
contribuyendo a la variabilidad general. Es decir, no hay patrones dominantes 
de variabilidad que puedan ser fácilmente capturados por los primeros 
componentes principales.
  
**CARGAS DE GENES EN PCA**  
  
Para entender mejor qué genes están contribuyendo a la separación observada, 
podemos analizar las cargas de los componentes principales para ver qué genes 
tienen mayores pesos en los componentes que diferencian los grupos.

```{r chunck PCA_0_2, fig.width=9, fig.height=5,}
# Extracción de cargas de componentes principales
cargas_pca <- pca_result$rotation  

# Mostramos las cargas de los primeros dos componentes
primer_componente <- cargas_pca[, 1]  
segundo_componente <- cargas_pca[, 2]  
```
  
**PC1**  

```{r chunck PCA_0_3, fig.width=9, fig.height=5,}
# Extraemos los top 10 genes y sus cargas de PC1
top_genes_pc1 <- head(sort(primer_componente, decreasing = TRUE), 10)

# Convertimos a data frame para visualización de PC1
top_genes_pc1_df <- data.frame(
  Gen = names(top_genes_pc1),
  Carga = top_genes_pc1
)
# Ordenamos el dataframe por carga de manera descendente
top_genes_pc1_df <- top_genes_pc1_df[order(top_genes_pc1_df$Carga, 
                                           decreasing = TRUE), ]
# Ajustamos los factores para que el orden de los genes sea según las cargas
top_genes_pc1_df$Gen <- factor(top_genes_pc1_df$Gen, levels = top_genes_pc1_df$Gen)

# Creamos el gráfico de barras
plot_pc1 <- ggplot(top_genes_pc1_df, aes(x = Gen, y = Carga, fill = Gen)) +
  geom_bar(stat = "identity", position = "dodge") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) +
  labs(title = "Top 10 Cargas de Genes en PC1",
       x = "Gen",
       y = "Carga") +
  scale_color_gradient(low = "peachpuff", high = "peachpuff4")

# Mostramos los top 10 genes de PC1
print(top_genes_pc1)
```

**PC2**  

```{r chunck PCA_0_4, fig.width=9, fig.height=5,}
# Extraemos los top 10 genes y sus cargas de PC2
top_genes_pc2 <- head(sort(segundo_componente, decreasing = TRUE), 10)

# Convertimos a data frame para visualización de PC2
top_genes_pc2_df <- data.frame(
  Gen = names(top_genes_pc2),
  Carga = top_genes_pc2
)
# Ordenamos el dataframe por carga de manera descendente
top_genes_pc2_df <- top_genes_pc2_df[order(top_genes_pc2_df$Carga, 
                                           decreasing = TRUE), ]
# Ajustamos los factores para que el orden de los genes sea según las cargas
top_genes_pc2_df$Gen <- factor(top_genes_pc2_df$Gen, levels = top_genes_pc2_df$Gen)

# Creamos el gráfico de barras
plot_pc2 <- ggplot(top_genes_pc2_df, aes(x = Gen, y = Carga, fill = Gen)) +
  geom_bar(stat = "identity", position = "dodge") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) +
  labs(title = "Top 10 Cargas de Genes en PC2",
       x = "Gen",
       y = "Carga") +
  scale_color_gradient(low = "peachpuff", high = "peachpuff4")

# Mostramos los top 10 genes de PC1
print(top_genes_pc2)

# Mostramos gráficamente las cargas del top 10 tanto de PC1 como de PC2 en un grid 2x1 (patchwork)
plot_pc1 + plot_pc2 + plot_layout(ncol = 2, nrow = 1)
```
  
**GRÁFICAS PCA** 
  
Utilizamos el paquete `factoextra` para realizar las gráficas de los 2 primeros 
componentes, en concreto cla función `fviz_pca_ind`, que además nos permite 
añadir las elipses de confianza.

## Estudios de origen 

Entre los diferentes grupos de estudio, las elipses de confianza están centradas
y solapadas lo que sugiere que, en el espacio de los primeros dos componentes 
principales, no hay una separación clara entre los grupos.
  
No es descartable la necesidad de examinar componentes adicionales o utilizar 
otras técnicas de análisis como métodos de *Clustering*.

```{r chunck PCA_1, fig.width=8, fig.height=8,}
# Utilizamos "factoextra" para hacer la gráfica de la PCA
# Hacemos la gráfica de los dos primeros componentes
fviz_pca_ind(pca_result,
             col.ind = df_dataClin$study, # Colores de los puntos basados en los estudios
             label = "none", 
             addEllipses = TRUE, # Añadir elipses de confianza
             ellipse.type = "confidence", # Tipo de elipse, puede ser 'confidence' o 't'
             legend.title = "Study",
             palette = "jco", # Paleta de colores, 'jco' es solo una opción
             title = "PCA Estudios")
```

## MSI/MSS

Cuando representamos la PCA por inestabilidad de microsatélites vemos que las 
dos elipses, las de MSI y las de MSS, están claramente separadas lo que sugiere 
que ambos grupos tienen perfiles de expresión genética distintos en las 
dimensiones capturadas por los componentes principales (CP).  
Como ya sabemos, estas diferencias son biológicamente relevantes; los componentes
que muestran esta separación probablemente están capturando las  variaciones 
genéticas ya conocidas de antemano. 
  
```{r chunck PCA_2, fig.width=8, fig.height=8,}
# Hacemos la gráfica de los dos primeros componentes en relación a los grupos 
fviz_pca_ind(pca_result,
             col.ind = df_dataClin$msi_imputed, # Colores de los puntos basados en MSI/MSS
             label = "none", 
             addEllipses = TRUE, # Añadir elipses de confianza
             ellipse.type = "confidence", # Tipo de elipse, puede ser 'confidence' o 't'
             legend.title = "MSI/MSS",
             palette = "jco", # Paleta de colores, 'jco' es solo una opción
             title = "PCA MSI/MSS")
```

## ESTADIO II/III

Entre los dos grupos de estadio, II y III, las elipses de confianza están más o 
menos centradas y algo solapadas lo que sugiere que, no hay una separación clara
entre los grupos. Algo un tanto previsible ya que el estadio del cáncer depende 
del **tiempo** de progreso de la enfermedad.  

```{r chunck PCA_3, fig.width=8, fig.height=8,}
# Hacemos la gráfica de los dos primeros componentes en relación a los grupos 
fviz_pca_ind(pca_result,
             col.ind = df_dataClin$stage, # Colores de los puntos basados en Estadio
             label = "none", 
             addEllipses = TRUE, # Añadir elipses de confianza
             ellipse.type = "confidence", # Tipo de elipse, puede ser 'confidence' o 't'
             legend.title = "Estadio",
             palette = "jco", # Paleta de colores, 'jco' es solo una opción
             title = "PCA Estadio II/III")
```

## MSI/MSS vs ESTADIO II/III

Se podría decir que esta gráfica és una combinación de las dos anteriores; 
fijándonos en las elipses de confianza, se observan dos grupos separados 
claramente de otros dos, debido principalmente a la contribución de la 
instabilidad de microsatélites y no tanto a la del estadio del CRC.  

```{r chunck PCA_4, fig.width=8, fig.height=8,}
# Hacemos la gráfica de los dos primeros componentes en relación a los grupos 
fviz_pca_ind(pca_result,
             col.ind = df_dataClin$grupo, # Colores de los puntos basados en Grupos
             label = "none", 
             addEllipses = TRUE, # Añadir elipses de confianza
             ellipse.type = "confidence", # Tipo de elipse, puede ser 'confidence' o 't'
             legend.title = "Grupo",
             palette = "jco", # Paleta de colores, 'jco' es solo una opción
             title = "PCA Grupos")
```

## CMS

Al igual que con la inestabilidad de microsatélites, cuando representamos la PCA
por clasificación CMS vemos que las cuatro elipses están claramente separadas; 
los 4 grupos tienen perfiles de expresión genética distintos en las dimensiones 
capturadas por los CP.  
Estas diferencias son biológicamente relevantes dado que los componentes
que muestran esta separación están capturando variaciones genéticas ya 
conocidas.

```{r chunck PCA_5, fig.width=8, fig.height=8,}
# Hacemos la gráfica de los dos primeros componentes en relación a los grupos 
fviz_pca_ind(pca_result,
             col.ind = df_dataClin$cms, # Colores de los puntos basados en CMS
             label = "none", 
             addEllipses = TRUE, # Añadir elipses de confianza
             ellipse.type = "confidence", # Tipo de elipse, puede ser 'confidence' o 't'
             legend.title = "CMS",
             palette = "jco", # Paleta de colores, 'jco' es solo una opción
             title = "PCA por CMS")
```

## CMS-ESTADIO

```{r chunck PCA_6, fig.width=8, fig.height=8,}
# Hacemos la gráfica de los dos primeros componentes en relación a los grupos 
fviz_pca_ind(pca_result,
             col.ind = df_dataClin$cms_stage, # Colores de los puntos basados en CMS
             label = "none", 
             addEllipses = TRUE, # Añadir elipses de confianza
             ellipse.type = "confidence", # Tipo de elipse, puede ser 'confidence' o 't'
             legend.title = "cms_stage",
             palette = "jco", # Paleta de colores, 'jco' es solo una opción
             title = "PCA por CMS-Estadio")
```

# Estimación de la infiltración celular {.tabset .tabset-fade .tabset-pills}

Analizamos los datos viendo la infiltración celular.  

Utilizamos el paquete `MCPcounter` [@becht2016estimating] que estima la 
abundancia poblacional de poblaciones de células inmunes (8 tipos) y estromales 
(2 tipos) que se infiltran en tejidos mediante la expresión genética.

En concreto, utilizatemos `MCPcounter` para estimar la infiltración celular del 
estroma y el sistema inmunitario en el microambiente tumoral (TME).


```{r chunck_4_1_1}
# Cargamos la librería "MCPcounter"
require(MCPcounter)

# Con todos los datos de la matriz de expresión 26/03/2024
exmat_MCP <- MCPcounter.estimate(expression = df_exmat, 
                                    featuresType = "HUGO_symbols")
# Transponemos
exmat_MCP <- t_df(exmat_MCP)
# Añadimos los datos clínicos a los datos de la matriz generada con MCPcounter 26/03/2024
exmat_MCP_Clin <- cbind(df_dataClin, exmat_MCP)

# Guardamos "df_dataClin", "df_exmat" y "exmat_MCP_Clin" en un archivo .Rdata.
# Lo hago para poder utilizar estos datos ya calculados en otros .rmd 21/04/2024
#save(df_dataClin, df_exmat, exmat_MCP_Clin, file = "tfm_SKF.RData")
```
  
A modo de recordatorio didáctico de *Inferencia Estadística*: 

* El **nivel de significación** $\alpha$ de un contraste es el error máximo de 
tipo I que estamos dispuestos a asumir.

|                   | $H_0$ es verdadera  | $H_0$ es falsa    |
|-------------------|---------------------|-------------------|
| Rechazar $H_0$    | Error Tipo I (α)    | Decisión Correcta |
| No rechazar $H_0$ | Decisión Correcta   | Error Tipo II (β) |
  

* El **p-valor** es la probabilidad del resultado del estadístico de contraste 
observado o de uno más alejado cuando la hipótesis nula es cierta.  

* El p-valor asociado a una observación del estadístico de contraste
es el menor nivel de significación que nos permite rechazar la hipótesis nula.  

* Si el p-valor es inferior al nivel de significación $\alpha$, rechazaremos la 
hipótesis nula, en caso contrario la aceptaremos.

En nuestro caso utilizamos un nivel de significación $\alpha = 0.05$

## Infiltración MSI/MSS vs stage {.tabset .tabset-fade}

### MSI/MSS vs stage de todos los tipos celulares

Para hacer una comparativa entre los 4 grupos, utilizaremos el test no 
paramétrico de **Kruskal-Wallis**. Se suele utilizar para determinar si hay 
diferencias significativas entre tres o más grupos independientes cuando los 
datos no cumplen los supuestos necesarios para realizar un ANOVA: normalidad y 
homocedasticidad (homogeneidad de varianzas).  

```{r chunck_4_1_2_1, echo=TRUE}
# Calculamos los test no paraméticos Kruskal-Wallis (asumimos que no tenemos normalidad) 16/04/2024

# tests de Kruskal-Wallis para NK
kw_NK_result <- kruskal.test(exmat_MCP_Clin$`NK cells` ~ grupo, data = exmat_MCP_Clin)

# Para el resto de tipos celulares utilizamos una lista con los nombres
tipos_celulares <- c("NK cells", "T cells", "CD8 T cells", "Cytotoxic lymphocytes", 
                     "B lineage", "Monocytic lineage", "Myeloid dendritic cells", 
                     "Neutrophils", "Endothelial cells", "Fibroblasts")

# Aplicamos el test de Kruskal-Wallis a cada tipo celular con "lapply"
resultados_kw <- lapply(tipos_celulares, function(cell_type) {
  kruskal.test(reformulate("grupo", response = cell_type), data = exmat_MCP_Clin)
})

# Añadimos los nombres de los tipos celulares 
names(resultados_kw) <- tipos_celulares

# Extraemos los valores de p de todos los tests realizados
p_valores <- sapply(resultados_kw, function(x) x$p.value)
```

La hipótesis nula del test de Kruskal-Wallis $H_0$ establece que todas las poblaciones
(grupos) tienen distribuciones idénticas, es decir, las medianas de todos los 
grupos son iguales.  

$$
H_0: \forall i, j \, (i \neq j) \Rightarrow \mu_i = \mu_j 
$$  

La hipótesis alternativa $H_1$ establece que al menos uno de los grupos tiene 
una distribución diferente en cuanto a la mediana, comparada con las otras 
poblaciones sin especificar cuál de los grupos es diferente.  

$$
H_1: \exists i \neq j \mid \mu_i \neq \mu_j
$$  
  

```{r chunck_4_1_2_2, fig.width=10, fig.height=5, echo=TRUE}
# Generamos todos los boxplot 27/03/2024
grupo <- exmat_MCP_Clin$grupo
# NK
bp1 <- boxplot_MCPcounter (exmat_MCP_Clin, grupo, exmat_MCP_Clin$`NK cells`, grupo, "NK cells", p_valores["NK cells"])
# T cells
bp2 <- boxplot_MCPcounter (exmat_MCP_Clin, grupo, exmat_MCP_Clin$`T cells`, grupo, "T cells", p_valores["T cells"])
# CD8 T cells
bp3 <- boxplot_MCPcounter (exmat_MCP_Clin, grupo, exmat_MCP_Clin$`CD8 T cells`, grupo, "CD8 T cells", p_valores["CD8 T cells"])
# Cytotoxic lymphocytes
bp4 <- boxplot_MCPcounter (exmat_MCP_Clin, grupo, exmat_MCP_Clin$`Cytotoxic lymphocytes`, grupo, "Cytotoxic lymphocytes", p_valores["Cytotoxic lymphocytes"])
# B lineage
bp5 <- boxplot_MCPcounter (exmat_MCP_Clin, grupo, exmat_MCP_Clin$`B lineage`, grupo, "B lineage", p_valores["B lineage"])
# Monocytic lineage
bp6 <- boxplot_MCPcounter (exmat_MCP_Clin, grupo, exmat_MCP_Clin$`Monocytic lineage`, grupo, "Monocytic lineage", p_valores["Monocytic lineage"])
# Myeloid dendritic cells
bp7 <- boxplot_MCPcounter (exmat_MCP_Clin, grupo, exmat_MCP_Clin$`Myeloid dendritic cells`, grupo, "Myeloid dendritic cells", p_valores["Myeloid dendritic cells"])
# Neutrophils
bp8 <- boxplot_MCPcounter (exmat_MCP_Clin, grupo, exmat_MCP_Clin$Neutrophils, grupo, "Neutrophils", p_valores["Neutrophils"])
# Endothelial cells
bp9 <- boxplot_MCPcounter (exmat_MCP_Clin, grupo, exmat_MCP_Clin$`Endothelial cells`, grupo, "Endothelial cells", p_valores["Endothelial cells"])
# Fibroblasts
bp10 <- boxplot_MCPcounter (exmat_MCP_Clin, grupo, exmat_MCP_Clin$Fibroblasts, grupo, "Fibroblasts", p_valores["Fibroblasts"])

# En un grid 3x2 (patchwork)
bp1 + bp2 + bp3 + plot_layout(ncol = 3, nrow = 1)
bp4 + bp5 + bp6 + plot_layout(ncol = 3, nrow = 1)
bp7 + bp8 + bp9 + plot_layout(ncol = 3, nrow = 1)
bp10 + plot_layout(ncol = 3, nrow = 1)
```

```{r chunck_4_1_2_3, fig.width=15, fig.height=15, echo=TRUE}
# Todos juntos para el informe del TFM 11/06/2024
bp1 + bp2 + bp3 + bp4 + bp5 + bp6 + bp7 + bp8 + bp9 + bp10 + plot_layout(ncol = 4, nrow = 3)
```


### Infiltración NKs

**NORMALIDAD Y HOMOCEDASTICIDAD**

Primero compromabos la normalidad de los grupos para las NK cells.

```{r chunck_4_1_3_0, echo=FALSE}

# Extraemos los datos de células NK para los distintos grupos MSI y MSS
grupo_msi <- exmat_MCP_Clin$`NK cells`[exmat_MCP_Clin$msi_imputed == "MSI"]
grupo_mss <- exmat_MCP_Clin$`NK cells`[exmat_MCP_Clin$msi_imputed == "MSS"]

# Realizamos la prueba de Shapiro-Wilk para MSI y MSS
shapiro_msi_NK <- shapiro.test(grupo_msi)
shapiro_mss_NK <- shapiro.test(grupo_mss)

# Extraemos los datos de células NK para los estadios II y III
grupo_sII <- exmat_MCP_Clin$`NK cells`[exmat_MCP_Clin$stage == "II"]
grupo_sIII <- exmat_MCP_Clin$`NK cells`[exmat_MCP_Clin$stage == "III"]

# Realizamos la prueba de Shapiro-Wilk para estadios II y III
shapiro_II_NK <- shapiro.test(grupo_sII)
shapiro_III_NK <- shapiro.test(grupo_sIII)
```

Tabla con los resultados de los **tests de Shapiro** para normalidad.  
Si p-value < 0.05 rechazamos la hipótesis nula de igualdad de estadísticos.

|Shapiro test | MSI  | MSS | II | III |
|--------|------|-----|-----|-----|
| p-valor | `r sprintf("%.3e", shapiro_msi_NK$p.value)` | `r sprintf("%.3e",shapiro_mss_NK$p.value)` | `r sprintf("%.3e", shapiro_II_NK$p.value)` | `r sprintf("%.3e",shapiro_III_NK$p.value)` |  
  
Dado que no hay normalidad no hace falta comprobar homocedasticidad.

Para realizar una comparativa entre dos grupos en los que asumimos no normalidad
, en nuestro caso MSI vs MSS y estadio II vs estadio III, utilizamos el test no 
paramétrico de **Mann-Whitney U** también conocido como el test de **Wilcoxon**
en el que se asume que los datos no necesitan ser normalmente distribuidos 
aunque deben poder ordenarse.  

```{r chunck_4_1_3_1, echo=TRUE}
# Para dos grupos utilizamos el test no paramético Mann-Whitney U (asumimos que no tenemos normalidad) 16/04/2024

# Realizamos el test de Mann-Whitney U para los grupos MSI y MSS
mwU_NK_msi_test <- wilcox.test(grupo_msi, grupo_mss, alternative = "two.sided")

# Realizamos el test de Mann-Whitney U para los estadios II y III
mwU_NK_stage_test <- wilcox.test(grupo_sII, grupo_sIII, alternative = "two.sided")
```

La hipótesis nula $H_0$ para el test de Mann-Whitney U establece que no hay diferencia
en las medianas (o, más generalmente, en las distribuciones) de los dos grupos: 
$$
H_0: \mu_{grupo1} = \mu_{grupo2}
$$
La hipótesis alternativa $H_1$ establece que hay una diferencia entre las 
distribuciones de los dos grupos. En nuestro caso la planteamos **Bilateral 
(Two-sided)**: 

$$
H_1: \mu_{grupo1} \neq \mu_{grupo2}
$$

```{r chunck_4_1_3_2, fig.width=9, fig.height=13, echo=TRUE}
# Generamos todos los boxplot referentes a NKs 27/03/2024  
# Diagrama de Barras de NKs MSI vs MSS
bp11 <- boxplot_MCPcounter (exmat_MCP_Clin, exmat_MCP_Clin$msi_imputed, 
                            exmat_MCP_Clin$`NK cells`, exmat_MCP_Clin$msi_imputed,
                            "NK cells MSI vs MSS", mwU_NK_msi_test$p.value)
# Diagrama de Barras de NKs II vs III
bp12 <- boxplot_MCPcounter (exmat_MCP_Clin, exmat_MCP_Clin$stage, 
                            exmat_MCP_Clin$`NK cells`, exmat_MCP_Clin$stage,
                            "NK cells II vs III", mwU_NK_stage_test$p.value)

# En un grid 2x2 (patchwork)
p3 + bp1 + p2+ bp11 + p1 + bp12 + plot_layout(ncol = 2, nrow = 3)
```

## Infiltración resto de tipos celulares {.tabset .tabset-fade}

### T cells

```{r chunck_4_2_1, fig.width=9, fig.height=5, echo=TRUE}
# Generamos todos los boxplot referentes 01/04/2024  
# Diagrama de Barras MSI vs MSS
bp13 <- boxplot_MCPcounter (exmat_MCP_Clin, exmat_MCP_Clin$msi_imputed, 
                            exmat_MCP_Clin$`T cells`, exmat_MCP_Clin$msi_imputed, "T cells MSI vs MSS")
# Diagrama de Barras II vs III
bp14 <- boxplot_MCPcounter (exmat_MCP_Clin, exmat_MCP_Clin$stage, 
                            exmat_MCP_Clin$`T cells`, exmat_MCP_Clin$stage, "T cells II vs III")

# En un grid 1x3 (patchwork)
bp2 + bp13 + bp14 + plot_layout(ncol = 3, nrow = 1)
```

### CD8 T cells

```{r chunck_4_2_2, fig.width=9, fig.height=5, echo=TRUE}
# Generamos todos los boxplot referentes 01/04/2024  
# Diagrama de Barras MSI vs MSS
bp15 <- boxplot_MCPcounter (exmat_MCP_Clin, exmat_MCP_Clin$msi_imputed, 
                            exmat_MCP_Clin$`CD8 T cells`, exmat_MCP_Clin$msi_imputed, "CD8 T cells MSI vs MSS")
# Diagrama de Barras II vs III
bp16 <- boxplot_MCPcounter (exmat_MCP_Clin, exmat_MCP_Clin$stage, 
                            exmat_MCP_Clin$`CD8 T cells`, exmat_MCP_Clin$stage, "CD8 T cells II vs III")

# En un grid 1x3 (patchwork)
bp3 + bp15 + bp16 + plot_layout(ncol = 3, nrow = 1)
```

### Cytotoxic lymphocytes

```{r chunck_4_2_3, fig.width=9, fig.height=5, echo=TRUE}
# Generamos todos los boxplot referentes 01/04/2024  
# Diagrama de Barras MSI vs MSS
bp17 <- boxplot_MCPcounter (exmat_MCP_Clin, exmat_MCP_Clin$msi_imputed, 
                            exmat_MCP_Clin$`Cytotoxic lymphocytes`, exmat_MCP_Clin$msi_imputed, "Cytotoxic lymphocytes MSI vs MSS")
# Diagrama de Barras II vs III
bp18 <- boxplot_MCPcounter (exmat_MCP_Clin, exmat_MCP_Clin$stage, 
                            exmat_MCP_Clin$`Cytotoxic lymphocytes`, exmat_MCP_Clin$stage, "Cytotoxic lymphocytes II vs III")

# En un grid 1x3 (patchwork)
bp4 + bp17 + bp18 + plot_layout(ncol = 3, nrow = 1)
```

### B lineage
  
```{r chunck_4_2_4, fig.width=9, fig.height=5, echo=TRUE}
# Generamos todos los boxplot referentes 01/04/2024  
# Diagrama de Barras MSI vs MSS
bp19 <- boxplot_MCPcounter (exmat_MCP_Clin, exmat_MCP_Clin$msi_imputed, 
                            exmat_MCP_Clin$`B lineage`, exmat_MCP_Clin$msi_imputed, "B lineage MSI vs MSS")
# Diagrama de Barras II vs III
bp20 <- boxplot_MCPcounter (exmat_MCP_Clin, exmat_MCP_Clin$stage, 
                            exmat_MCP_Clin$`B lineage`, exmat_MCP_Clin$stage, "B lineage II vs III")

# En un grid 1x3 (patchwork)
bp5 + bp19 + bp20 + plot_layout(ncol = 3, nrow = 1)
```

### Monocytic lineage

```{r chunck_4_2_5, fig.width=9, fig.height=5, echo=TRUE}
# Generamos todos los boxplot referentes 01/04/2024  
# Diagrama de Barras MSI vs MSS
bp21 <- boxplot_MCPcounter (exmat_MCP_Clin, exmat_MCP_Clin$msi_imputed, 
                            exmat_MCP_Clin$`Monocytic lineage`, exmat_MCP_Clin$msi_imputed, "Monocytic lineage MSI vs MSS")
# Diagrama de Barras II vs III
bp22 <- boxplot_MCPcounter (exmat_MCP_Clin, exmat_MCP_Clin$stage, 
                            exmat_MCP_Clin$`Monocytic lineage`, exmat_MCP_Clin$stage, "Monocytic lineage II vs III")

# En un grid 1x3 (patchwork)
bp6 + bp21 + bp22 + plot_layout(ncol = 3, nrow = 1)
```

### Myeloid dendritic cells

```{r chunck_4_2_6, fig.width=9, fig.height=5, echo=TRUE}
# Generamos todos los boxplot referentes 01/04/2024  
# Diagrama de Barras MSI vs MSS
bp23 <- boxplot_MCPcounter (exmat_MCP_Clin, exmat_MCP_Clin$msi_imputed, 
                            exmat_MCP_Clin$`Myeloid dendritic cells`, exmat_MCP_Clin$msi_imputed, "Myeloid dendritic cells MSI vs MSS")
# Diagrama de Barras II vs III
bp24 <- boxplot_MCPcounter (exmat_MCP_Clin, exmat_MCP_Clin$stage, 
                            exmat_MCP_Clin$`Myeloid dendritic cells`, exmat_MCP_Clin$stage, "Myeloid dendritic cells II vs III")

# En un grid 1x3 (patchwork)
bp7 + bp23 + bp24 + plot_layout(ncol = 3, nrow = 1)
```

### Neutrophils

```{r chunck_4_2_7, fig.width=9, fig.height=5, echo=TRUE}
# Generamos todos los boxplot referentes 01/04/2024  
# Diagrama de Barras MSI vs MSS
bp25 <- boxplot_MCPcounter (exmat_MCP_Clin, exmat_MCP_Clin$msi_imputed, 
                            exmat_MCP_Clin$`Neutrophils`, exmat_MCP_Clin$msi_imputed, "Neutrophils MSI vs MSS")
# Diagrama de Barras II vs III
bp26 <- boxplot_MCPcounter (exmat_MCP_Clin, exmat_MCP_Clin$stage, 
                            exmat_MCP_Clin$`Neutrophils`, exmat_MCP_Clin$stage, "Neutrophils II vs III")

# En un grid 1x3 (patchwork)
bp8 + bp25 + bp26 + plot_layout(ncol = 3, nrow = 1)
```

### Endothelial cells

```{r chunck_4_2_8, fig.width=9, fig.height=5, echo=TRUE}
# Generamos todos los boxplot referentes 01/04/2024  
# Diagrama de Barras MSI vs MSS
bp27 <- boxplot_MCPcounter (exmat_MCP_Clin, exmat_MCP_Clin$msi_imputed, 
                            exmat_MCP_Clin$`Endothelial cells`, exmat_MCP_Clin$msi_imputed, "Endothelial cells MSI vs MSS")
# Diagrama de Barras II vs III
bp28 <- boxplot_MCPcounter (exmat_MCP_Clin, exmat_MCP_Clin$stage, 
                            exmat_MCP_Clin$`Endothelial cells`, exmat_MCP_Clin$stage, "Endothelial cells II vs III")

# En un grid 1x3 (patchwork)
bp9 + bp27 + bp28 + plot_layout(ncol = 3, nrow = 1)
```

### Fibroblasts

```{r chunck_4_2_9, fig.width=9, fig.height=5, echo=TRUE}
# Generamos todos los boxplot referentes 01/04/2024  
# Diagrama de Barras MSI vs MSS
bp29 <- boxplot_MCPcounter (exmat_MCP_Clin, exmat_MCP_Clin$msi_imputed, 
                            exmat_MCP_Clin$`Fibroblasts`, exmat_MCP_Clin$msi_imputed, "Fibroblasts MSI vs MSS")
# Diagrama de Barras II vs III
bp30 <- boxplot_MCPcounter (exmat_MCP_Clin, exmat_MCP_Clin$stage, 
                            exmat_MCP_Clin$`Fibroblasts`, exmat_MCP_Clin$stage, "Fibroblasts II vs III")

# En un grid 1x3 (patchwork)
bp10 + bp29 + bp30 + plot_layout(ncol = 3, nrow = 1)
```

### NK cells

```{r chunck_4_2_10, fig.width=9, fig.height=5, echo=TRUE}
# En un grid 1x3
bp1 + bp11 + bp12 + plot_layout(ncol = 3, nrow = 1)
```


# Análisis CMS {.tabset .tabset-fade .tabset-pills}
  
La clasificación CMS divide los tumores de CRC en cuatro subtipos principales, 
basados en características moleculares distintas, lo que refleja diferencias en 
la biología del tumor, la interacción con el TME, el pronóstico y la respuesta a
tratamientos específicos. [@roelands2017immunogenomic]

| Subtipo | Características | Inmunidad | Prevalencia |
|---------|-----------------|-----------|-------------|
| CMS1 (Subtipo Inmuno) | Alta inmunogenicidad, frecuentemente asociada con MSI y una alta carga mutacional. | Tienen una infiltración activa de células inmunitarias efectoras, lo que puede hacerlos más susceptibles a terapias inmunogénicas. | Aproximadamente el 14% de los casos de CRC. |
| CMS2 (Subtipo Canónico) | Tumores con alta expresión de genes relacionados con el ciclo celular y la señalización WNT/MYC, presentando una marcada proliferación celular. | Son generalmente poco inmunogénicos, con menor infiltración inmune comparado con CMS1 y CMS4. | Es el subtipo más común, abarcando alrededor del 37% de los casos de CRC. |
| CMS3 (Subtipo Metabólico) | Presenta alteraciones metabólicas, incluyendo un metabolismo energético distintivo, con una menor carga mutacional en comparación con CMS1. | Similar a CMS2, muestra baja inmunogenicidad. | Constituye aproximadamente el 13% de los casos de CRC |
| CMS4 (Subtipo Mesenquimal) | Se caracteriza por la activación de vías relacionadas con la angiogénesis, la activación de células estromales y la señalización TGF-β, lo que conduce a un entorno inmunosupresor. | Aunque presenta una significativa infiltración inmune, esta es predominantemente de naturaleza supresora, con una alta presencia de células estromales. | Aproximadamente el 23% de los casos de CRC caen en este subtipo.

## Infiltración CMS
 |
Vemos la infiltración celular según CMS e inestabilidad de microsatélites.

```{r chunck_6_1, echo=TRUE}
# Calculamos los test no paraméticos Kruskal-Wallis (asumimos que no tenemos normalidad) 16/04/2024

# Aplicamos el test de Kruskal-Wallis a cada tipo celular con "lapply"
resultados_kw_cms <- lapply(tipos_celulares, function(cell_type) {
  kruskal.test(reformulate("cms", response = cell_type), data = exmat_MCP_Clin)
})

# Añadimos los nombres de los tipos celulares 
names(resultados_kw_cms) <- tipos_celulares

# Extraemos los valores de p de todos los tests realizados
p_valores_cms <- sapply(resultados_kw_cms, function(x) x$p.value)
```

```{r chunck_6_2, fig.width=10, fig.height=5, echo=TRUE}
# Quitamos los NA's de la columna cms 
exmat_MCP_Clin_CMS <- exmat_MCP_Clin[!is.na(exmat_MCP_Clin$cms), ]
# Generamos todos los boxplot 02/04/2024
cms <- exmat_MCP_Clin_CMS$cms
# NK
bp1 <- boxplot_MCPcounter (exmat_MCP_Clin_CMS, cms, exmat_MCP_Clin_CMS$`NK cells`, cms, "NK cells", p_valores_cms["NK cells"])
# T cells
bp2 <- boxplot_MCPcounter (exmat_MCP_Clin_CMS, cms, exmat_MCP_Clin_CMS$`T cells`, cms, "T cells", p_valores_cms["T cells"])
# CD8 T cells
bp3 <- boxplot_MCPcounter (exmat_MCP_Clin_CMS, cms, exmat_MCP_Clin_CMS$`CD8 T cells`, cms, "CD8 T cells", p_valores_cms["CD8 T cells"])
# Cytotoxic lymphocytes
bp4 <- boxplot_MCPcounter (exmat_MCP_Clin_CMS, cms, exmat_MCP_Clin_CMS$`Cytotoxic lymphocytes`, cms, "Cytotoxic lymphocytes", p_valores_cms["Cytotoxic lymphocytes"])
# B lineage
bp5 <- boxplot_MCPcounter (exmat_MCP_Clin_CMS, cms, exmat_MCP_Clin_CMS$`B lineage`, cms, "B lineage", p_valores_cms["B lineage"])
# Monocytic lineage
bp6 <- boxplot_MCPcounter (exmat_MCP_Clin_CMS, cms, exmat_MCP_Clin_CMS$`Monocytic lineage`, cms, "Monocytic lineage", p_valores_cms["Monocytic lineage"])
# Myeloid dendritic cells
bp7 <- boxplot_MCPcounter (exmat_MCP_Clin_CMS, cms, exmat_MCP_Clin_CMS$`Myeloid dendritic cells`, cms, "Myeloid dendritic cells", p_valores_cms["Myeloid dendritic cells"])
# Neutrophils
bp8 <- boxplot_MCPcounter (exmat_MCP_Clin_CMS, cms, exmat_MCP_Clin_CMS$Neutrophils, cms, "Neutrophils", p_valores_cms["Neutrophils"])
# Endothelial cells
bp9 <- boxplot_MCPcounter (exmat_MCP_Clin_CMS, cms, exmat_MCP_Clin_CMS$`Endothelial cells`, cms, "Endothelial cells", p_valores_cms["Endothelial cells"])
# Fibroblasts
bp10 <- boxplot_MCPcounter (exmat_MCP_Clin_CMS, cms, exmat_MCP_Clin_CMS$Fibroblasts, cms, "Fibroblasts", p_valores_cms["Fibroblasts"])

# En un grid 3x2 (patchwork)
p2 + bp1 + bp2  + plot_layout(ncol = 3, nrow = 1)
bp3 + bp4 + bp5 + plot_layout(ncol = 3, nrow = 1)
bp6 + bp7 + bp8 + plot_layout(ncol = 3, nrow = 1)
bp9 +  bp10 + plot_layout(ncol = 3, nrow = 1)
```
  
Los tumores CMS2 y CMS3 son poco inmunogénicos; CMS1 y CMS4 difieren en el tipo de infiltración inmune.   
Los tumores CMS1 tienden a acumular una gran cantidad de mutaciones debido al estado de MSI y atraen células efectoras inmunes.  
Los tumores CMS4 exhiben un TME inmunosupresor con infiltración estromal. [@lanuza2022adoptive]

## Infiltración CMS-ESTADIO
 |
Vemos la infiltración celular según CMS y estadio.

```{r chunck_6_3, echo=TRUE}
# Calculamos los test no paraméticos Kruskal-Wallis (asumimos que no tenemos normalidad) 22/04/2024

# Aplicamos el test de Kruskal-Wallis a cada tipo celular con "lapply"
resultados_kw_cms_stage <- lapply(tipos_celulares, function(cell_type) {
  kruskal.test(reformulate("cms_stage", response = cell_type), data = exmat_MCP_Clin)
})

# Añadimos los nombres de los tipos celulares 
names(resultados_kw_cms_stage) <- tipos_celulares

# Extraemos los valores de p de todos los tests realizados
p_valores_cms_stage <- sapply(resultados_kw_cms_stage, function(x) x$p.value)
```

```{r chunck_6_4, fig.width=10, fig.height=5, echo=TRUE}
# Quitamos los NA's de la columna cms 
exmat_MCP_Clin_CMS_stage <- exmat_MCP_Clin[!is.na(exmat_MCP_Clin$cms_stage), ]
# Generamos todos los boxplot 02/04/2024
cms_stage <- exmat_MCP_Clin_CMS$cms_stage
# NK
bp1 <- boxplot_MCPcounter (exmat_MCP_Clin_CMS_stage, cms_stage, exmat_MCP_Clin_CMS_stage$`NK cells`, cms_stage, "NK cells", p_valores_cms_stage["NK cells"])
# T cells
bp2 <- boxplot_MCPcounter (exmat_MCP_Clin_CMS_stage, cms_stage, exmat_MCP_Clin_CMS_stage$`T cells`, cms_stage, "T cells", p_valores_cms_stage["T cells"])
# CD8 T cells
bp3 <- boxplot_MCPcounter (exmat_MCP_Clin_CMS, cms_stage, exmat_MCP_Clin_CMS$`CD8 T cells`, cms_stage, "CD8 T cells", p_valores_cms_stage["CD8 T cells"])
# Cytotoxic lymphocytes
bp4 <- boxplot_MCPcounter (exmat_MCP_Clin_CMS_stage, cms_stage, exmat_MCP_Clin_CMS_stage$`Cytotoxic lymphocytes`, cms_stage, "Cytotoxic lymphocytes", p_valores_cms_stage["Cytotoxic lymphocytes"])
# B lineage
bp5 <- boxplot_MCPcounter (exmat_MCP_Clin_CMS_stage, cms_stage, exmat_MCP_Clin_CMS_stage$`B lineage`, cms_stage, "B lineage", p_valores_cms_stage["B lineage"])
# Monocytic lineage
bp6 <- boxplot_MCPcounter (exmat_MCP_Clin_CMS_stage, cms_stage, exmat_MCP_Clin_CMS_stage$`Monocytic lineage`, cms_stage, "Monocytic lineage", p_valores_cms_stage["Monocytic lineage"])
# Myeloid dendritic cells
bp7 <- boxplot_MCPcounter (exmat_MCP_Clin_CMS_stage, cms_stage, exmat_MCP_Clin_CMS_stage$`Myeloid dendritic cells`, cms_stage, "Myeloid dendritic cells", p_valores_cms_stage["Myeloid dendritic cells"])
# Neutrophils
bp8 <- boxplot_MCPcounter (exmat_MCP_Clin_CMS_stage, cms_stage, exmat_MCP_Clin_CMS_stage$Neutrophils, cms_stage, "Neutrophils", p_valores_cms_stage["Neutrophils"])
# Endothelial cells
bp9 <- boxplot_MCPcounter (exmat_MCP_Clin_CMS_stage, cms_stage, exmat_MCP_Clin_CMS_stage$`Endothelial cells`, cms_stage, "Endothelial cells", p_valores_cms_stage["Endothelial cells"])
# Fibroblasts
bp10 <- boxplot_MCPcounter (exmat_MCP_Clin_CMS_stage, cms_stage, exmat_MCP_Clin_CMS_stage$Fibroblasts, cms_stage, "Fibroblasts", p_valores_cms_stage["Fibroblasts"])

# En un grid 2x1 (patchwork)
bp1 + bp2  + plot_layout(ncol = 2, nrow = 1)
bp3 + bp4 + plot_layout(ncol = 2, nrow = 1)
bp5 + bp6 + plot_layout(ncol = 2, nrow = 1)
bp7 +  bp8 + plot_layout(ncol = 2, nrow = 1)
bp9 +  bp10 + plot_layout(ncol = 2, nrow = 1)
p5 + plot_layout(ncol = 2, nrow = 1)
```

# Análisis HLA's {.tabset .tabset-fade .tabset-pills}

Hacemos un data frame con los datos de expresión de los genes del *Complejo Mayor
de Hitocompatibilidad I HLA-A, HLA-B, HLA-C* y el gen marcador de las células NK,
*NKp46* (*NCR1* en nomenclatura SYMBOL). Además añadimos la columna HLA-ABC con 
la suma de expresión de los 3 genes.    
  
```{r chunck_HLA_1, echo=TRUE}
# Nos quedamos solo con los genes del complejo mayor de hitocompatibilidad I 
# HLA-ABC y con el marcador de células NK, el gen NKp46 (NCR1 en nomenclatura SYMBOL) 
hla_nk_genes <- c("HLA-A", "HLA-B", "HLA-C", "HLA-E", "NCR1")
df_hla_nk_expression <- df_exmat_t[hla_nk_genes]
# Calculamos la mediana de la columna HLA-A
median_hla_a <- median(df_hla_nk_expression$`HLA-A`, na.rm = TRUE)
# Calculamos la mediana de la columna HLA-A
median_hla_b <- median(df_hla_nk_expression$`HLA-B`, na.rm = TRUE)
# Calculamos la mediana de la columna HLA-A
median_hla_c <- median(df_hla_nk_expression$`HLA-C`, na.rm = TRUE)
# Calculamos la mediana de la columna HLA-E
median_hla_e <- median(df_hla_nk_expression$`HLA-E`, na.rm = TRUE)

# Añadimos una nueva columna que indique si el nivel de HLA-A es 'Low' o 'High'
df_hla_nk_expression$HLA_A_cat <- ifelse(df_hla_nk_expression$`HLA-A` < median_hla_a, 'Low', 'High')
# Convertimos la columna 'HLA_A_cat' a factor
df_hla_nk_expression$HLA_A_cat <- factor(df_hla_nk_expression$HLA_A_cat, levels = c('Low', 'High'))

# Añadimos una nueva columna que indique si el nivel de HLA-B es 'Low' o 'High'
df_hla_nk_expression$HLA_B_cat <- ifelse(df_hla_nk_expression$`HLA-B` < median_hla_b, 'Low', 'High')
# Convertimos la columna 'HLA_B_cat' a factor
df_hla_nk_expression$HLA_B_cat <- factor(df_hla_nk_expression$HLA_B_cat, levels = c('Low', 'High'))

# Añadimos una nueva columna que indique si el nivel de HLA-C es 'Low' o 'High'
df_hla_nk_expression$HLA_C_cat <- ifelse(df_hla_nk_expression$`HLA-C` < median_hla_c, 'Low', 'High')
# Convertimos la columna 'HLA_C_cat' a factor
df_hla_nk_expression$HLA_C_cat <- factor(df_hla_nk_expression$HLA_C_cat, levels = c('Low', 'High'))

# Añadimos una nueva columna que indique si el nivel de HLA-E es 'Low' o 'High'
df_hla_nk_expression$HLA_E_cat <- ifelse(df_hla_nk_expression$`HLA-E` < median_hla_e, 'Low', 'High')
# Convertimos la columna 'HLA_E_cat' a factor
df_hla_nk_expression$HLA_E_cat <- factor(df_hla_nk_expression$HLA_E_cat, levels = c('Low', 'High'))

# Añadimos los datos clínicos
df_hla_nk_expression <- cbind(exmat_MCP_Clin, df_hla_nk_expression)
```


```{r chunck_HLA_2, fig.width=10, fig.height=10, echo=FALSE, include = FALSE}
# Creamos el gráfico de dispersión
pd1 <- ggplot(df_hla_nk_expression, aes(x = `HLA-A`, y = NCR1)) + 
    # Agregamos puntos con colores y formas personalizados
    geom_point(aes(shape = stage, color = msi_imputed, fill = msi_imputed), size = 3, stroke = 1) + # Agregar etiquetas y título
    labs(title = "Gráfico de dispersión NKP46 vs HLA-A",
       x = "HLA-A",
       y = "NKP46 (NCR1)",
       color = "MSI/MSS",
       shape = "Stage") +
    # Ajustar la escala de forma y relleno
    # Shape: 21: círculo relleno, 24: triángulo relleno
    scale_shape_manual(values = c(21, 24)) + 
    scale_fill_manual(values = c("white", "dodgerblue4")) +
    scale_color_manual(values = c("darkorange2", "dodgerblue4")) + 
    # Personalizar el tema del gráfico
    theme_classic() +
    theme(
      axis.line = element_line(color = "black"),
      legend.position = c(0.1, 0.9)) +
    # Quitamos la leyenda fill
     guides(fill = "none")
# Visualizamos
pd1
```


```{r chunck_HLA_3, echo=FALSE, include = FALSE}
# Ajustamos un modelo lineal sin considerar interación entre *estadio* e *inestabilidad de microsatélites*

# Ajustamos un modelo lineal
lmod <- lm(NCR1 ~ `HLA-A`, data = df_hla_nk_expression)
# Summary del modelo
summary(lmod)

# - Hay una potencial relación positiva entre HLA-A y NCR1, pero no es 
# suficiente para afirmar que es significativa.
# - Débil explicación del modelo.  
```

## HLA-A {.tabset}

### Boxplot HLA-A Cat vs NKp46

Boxplot comparando la expresión del gen NKp46 entre las categorías baja (Low) y 
alta (High) de HLA-A. Para realizar las categorías  se ha utilizado la mediana
de la expresión génica como punto de corte.  
Se ha estratificando por estadio y MSI/MSS. 
Utilizamos el test no paramétrico de Wilcoxon para evaluar las diferencias.  

```{r chunck_HLA_8, fig.width=10, fig.height=10, echo=TRUE}
# Función para generar gráficos de caja y pruebas de Mann-Whitney U
boxplot_MWU <- function(data, stage, msi, hla_var, nk_var, title_prefix) {
  # Filtrar los datos
  df_filtered <- sqldf(paste0("SELECT * FROM df_hla_nk_expression WHERE stage = '", stage, "' AND msi_imputed = '", msi, "'"))
  
  # Realizar el test de Mann-Whitney U para los grupos Low y High
  nLow <- df_filtered$NCR1[df_filtered[[hla_var]] == "Low"]
  nHigh <- df_filtered$NCR1[df_filtered[[hla_var]] == "High"]
  mwU_test <- wilcox.test(nLow, nHigh, alternative = "two.sided")
  
  # Generar el título completo
  title <- paste0(title_prefix, ", ", stage, ", ", msi)
  
  # Generar el boxplot
  bp <- boxplot_MCPcounter(data = df_filtered, 
                           x = df_filtered[[hla_var]], 
                           y = df_filtered[[nk_var]], 
                           fill = df_filtered[[hla_var]], 
                           title = title, 
                           p_value = mwU_test$p.value, 
                           xlabel = hla_var, ylabel = nk_var)
  
  return(bp)
}
```

```{r chunck_HLA_8_1, fig.width=10, fig.height=10, echo=TRUE}
# Generar los gráficos para cada combinación de stage, msi y HLA variable
bp35 <- boxplot_MWU(data = df_hla_nk_expression, stage = "II", msi = "MSI", hla_var = "HLA_A_cat", nk_var = "NCR1", title_prefix = "StageII")
bp36 <- boxplot_MWU(data = df_hla_nk_expression, stage = "II", msi = "MSS", hla_var = "HLA_A_cat", nk_var = "NCR1", title_prefix = "StageII")
bp37 <- boxplot_MWU(data = df_hla_nk_expression, stage = "III", msi = "MSI", hla_var = "HLA_A_cat", nk_var = "NCR1", title_prefix = "StageIII")
bp38 <- boxplot_MWU(data = df_hla_nk_expression, stage = "III", msi = "MSS", hla_var = "HLA_A_cat", nk_var = "NCR1", title_prefix = "StageIII")

# Visualizar los gráficos en un grid 2x2 (patchwork)
bp35 + bp36 + bp37 + bp38 + plot_layout(ncol = 2, nrow = 2)
```

No da significación en ningún caso. 
No hay una diferencia signficativa en la mediana de la expresión del gen NCR1 
entre los grupos con baja y alta expresión de HLA-A.

### Estadio II - MSI/MSS HLA-A 

```{r chunck_HLA_4, fig.width=10, fig.height=10, echo=TRUE}
# Seleccionamos estadio tipo II
df_hla_nk_expression_II <- sqldf('SELECT * FROM df_hla_nk_expression WHERE stage = "II"')

# Creamos el gráfico de dispersión para Estadio II
pd2 <- ggplot(df_hla_nk_expression_II, aes(x = `HLA-A`, y = NCR1)) +
  geom_point(aes(color = msi_imputed, shape = msi_imputed), size = 3, stroke = 1) +
  labs(title = "Estadio II",
       x = "HLA-A",
       y = "NKP46 (NCR1)",
       color = "MSI/MSS",
       shape = "MSI/MSS") +
  scale_shape_manual(values = c(16, 2)) +  # cuadrado lleno, triángulo
  scale_color_manual(values = c("darkorange2", "dodgerblue4")) +
  theme_classic() +
  theme(
    axis.line = element_line(color = "black"),
    legend.position = c(0.1, 0.9))

# Añadimos líneas de regresión lineal para cada grupo MSI y MSS
pd2 <- pd2 + geom_smooth(method = "lm", aes(color = msi_imputed), se = FALSE)

# Visualizamos el gráfico
pd2
```


```{r chunck_HLA_5, fig.width=10, fig.height=10, echo=TRUE}
# Ajustamos un modelo lineal para Estadio II
lmod_ser <- lm(NCR1 ~ `HLA-A`*msi_imputed, data = df_hla_nk_expression_II)
# Hacemos una contraste de paralelismo de rectas con anova
anova(lmod_ser)
```

El efecto principal de HLA-A sobre NCR1 no es significativo (p = 0.641981). Esto
sugiere que no hay suficiente evidencia para concluir que HLA-A tiene un efecto significativo en NCR1 por sí solo.  

El efecto msi_imputed sobre NCR1 no es significativo (p = 0.159859). Esto indica que no hay suficiente evidencia para concluir que msi_imputed tiene un efecto significativo en NCR1 por sí solo.

Vemos que hay significación en la hipótesis de paralelismo (Pr: 0.002474).La 
interacción entre HLA-A y msi_imputed es significativa. Esto indica que el 
efecto de HLA-A sobre NCR1 depende de los valores de msi_imputed. Dado que el 
p-valor es menor que 0.01 (**), hay una fuerte evidencia contra la hipótesis 
nula de que no hay interacción entre HLA-A y msi_imputed.

Aquí se observa para los tumores MSI una relación inversa entre la expresión de 
NCR1 y HLA-A; Cuanta menor expresión de HLA's hay una mayor expresión de NKp46,
es decir, cuanta menor expresión de HLA-A hay una mayor infiltración de células 
NK activadas.

### Estadio III - MSI/MSS HLA-A 

```{r chunck_HLA_6, fig.width=10, fig.height=10, echo=TRUE}
# Seleccionamos estadio tipo II
df_hla_nk_expression_III <- sqldf('SELECT * FROM df_hla_nk_expression WHERE stage = "III"')

# Creamos el gráfico de dispersión para Estadio II
pd3 <- ggplot(df_hla_nk_expression_III, aes(x = `HLA-A`, y = NCR1)) +
  geom_point(aes(color = msi_imputed, shape = msi_imputed), size = 3, stroke = 1) +
  labs(title = "Estadio III",
       x = "HLA-A",
       y = "NKP46 (NCR1)",
       color = "MSI/MSS",
       shape = "MSI/MSS") +
  scale_shape_manual(values = c(16, 2)) +  # cuadrado lleno, triángulo
  scale_color_manual(values = c("darkorange2", "dodgerblue4")) +
  theme_classic() +
  theme(
    axis.line = element_line(color = "black"),
    legend.position = c(0.1, 0.9))

# Añadimos líneas de regresión lineal para cada grupo MSI y MSS
pd3 <- pd3 + geom_smooth(method = "lm", aes(color = msi_imputed), se = FALSE)

# Visualizamos el gráfico
pd3
```


```{r chunck_HLA_7, fig.width=10, fig.height=10, echo=TRUE}
# Ajustamos un modelo lineal para Estadio II
lmod_ser <- lm(NCR1 ~ `HLA-A`*msi_imputed, data = df_hla_nk_expression_III)
# Hacemos una contraste de paralelismo de rectas con anova
anova(lmod_ser)
```

El efecto principal de HLA-A sobre NCR1 es significativo (p = 0.028028). Esto 
sugiere que hay una relación significativa entre HLA-A y NCR1 por sí solo. Dado 
que el p-valor es menor que 0.05 (*), hay suficiente evidencia para rechazar la 
hipótesis nula de que HLA-A no tiene un efecto sobre NCR1.

El efecto principal de msi_imputed sobre NCR1 es significativo (p = 0.005213). 
Esto indica que hay una relación significativa entre msi_imputed y NCR1 por sí 
solo. Dado que el p-valor es menor que 0.01 (**), hay una fuerte evidencia para 
rechazar la hipótesis nula de que msi_imputed no tiene un efecto sobre NCR1.

La interacción entre HLA-A y msi_imputed no es significativa (p = 0.815465). 
Esto indica que no hay suficiente evidencia para concluir que el efecto de HLA-A
sobre NCR1 depende de los valores de msi_imputed.

En este caso no hay significación en la hipótesis de paralelismo (Pr: 0.738591) 
aunque sí en la de coincidencia de las rectas (Pr: 0.006508). Resultado también 
de difícil interpretación: los efectos principales de HLA-ABC y msi_imputed son 
ambos estadísticamente significativos y aportan individualmente a la explicación
de la variabilidad en NCR1, con msi_imputed mostrando un efecto algo más fuerte 
según valor p más bajos.
  
Aquí se intuye una relación inversa entre la expresión de NCR1 y HLA-A; es 
decir, una relación inversa entre infiltración de células NK y expresión de 
HLA's.
  
## HLA-B {.tabset}

### Boxplot HLA-B Cat vs NKp46

Boxplot comparando la expresión del gen NKp46 entre las categorías baja (Low) y 
alta (High) de HLA-B. Para realizar las categorías  se ha utilizado la mediana
de la expresión génica como punto de corte.  
Se ha estratificando por estadio y MSI/MSS. 
Utilizamos el test no paramétrico de Wilcoxon para evaluar las diferencias.  

```{r chunck_HLA_9, fig.width=10, fig.height=10, echo=TRUE}
# Generar los gráficos para cada combinación de stage, msi y HLA variable
bp39 <- boxplot_MWU(data = df_hla_nk_expression, stage = "II", msi = "MSI", hla_var = "HLA_B_cat", nk_var = "NCR1", title_prefix = "StageII")
bp40 <- boxplot_MWU(data = df_hla_nk_expression, stage = "II", msi = "MSS", hla_var = "HLA_B_cat", nk_var = "NCR1", title_prefix = "StageII")
bp41 <- boxplot_MWU(data = df_hla_nk_expression, stage = "III", msi = "MSI", hla_var = "HLA_B_cat", nk_var = "NCR1", title_prefix = "StageIII")
bp42 <- boxplot_MWU(data = df_hla_nk_expression, stage = "III", msi = "MSS", hla_var = "HLA_B_cat", nk_var = "NCR1", title_prefix = "StageIII")


# Visualizar los gráficos en un grid 2x2 (patchwork)
bp39 + bp40 + bp41 + bp42 + plot_layout(ncol = 2, nrow = 2)
```

Nos da significación en el primer caso StageII, MSI. 

## HLA-C {.tabset}

### Boxplot HLA-C Cat vs NKp46

Boxplot comparando la expresión del gen NKp46 entre las categorías baja (Low) y 
alta (High) de HLA-C. Para realizar las categorías  se ha utilizado la mediana
de la expresión génica como punto de corte.  
Se ha estratificando por estadio y MSI/MSS. 
Utilizamos el test no paramétrico de Wilcoxon para evaluar las diferencias.  

```{r chunck_HLA_10, fig.width=10, fig.height=10, echo=TRUE}
# Generar los gráficos para cada combinación de stage, msi y HLA variable
bp43 <- boxplot_MWU(data = df_hla_nk_expression, stage = "II", msi = "MSI", hla_var = "HLA_C_cat", nk_var = "NCR1", title_prefix = "StageII")
bp44 <- boxplot_MWU(data = df_hla_nk_expression, stage = "II", msi = "MSS", hla_var = "HLA_C_cat", nk_var = "NCR1", title_prefix = "StageII")
bp45 <- boxplot_MWU(data = df_hla_nk_expression, stage = "III", msi = "MSI", hla_var = "HLA_C_cat", nk_var = "NCR1", title_prefix = "StageIII")
bp46 <- boxplot_MWU(data = df_hla_nk_expression, stage = "III", msi = "MSS", hla_var = "HLA_C_cat", nk_var = "NCR1", title_prefix = "StageIII")

# Visualizar los gráficos en un grid 2x2 (patchwork)
bp43 + bp44 + bp45 + bp46 + plot_layout(ncol = 2, nrow = 2)
```

Nos da significación en los casos StageII, MSS y StageIII, MSS. 

## HLA-E {.tabset}

### Boxplot HLA-E Cat vs NKp46

Boxplot comparando la expresión del gen NKp46 entre las categorías baja (Low) y 
alta (High) de HLA-E. Para realizar las categorías  se ha utilizado la mediana
de la expresión génica como punto de corte.  
Se ha estratificando por estadio y MSI/MSS. 
Utilizamos el test no paramétrico de Wilcoxon para evaluar las diferencias.  

```{r chunck_HLA_15, fig.width=10, fig.height=10, echo=TRUE}

bp47 <- boxplot_MWU(data = df_hla_nk_expression, stage = "II", msi = "MSI", hla_var = "HLA_E_cat", nk_var = "NCR1", title_prefix = "StageII")
bp48 <- boxplot_MWU(data = df_hla_nk_expression, stage = "II", msi = "MSS", hla_var = "HLA_E_cat", nk_var = "NCR1", title_prefix = "StageII")
bp49 <- boxplot_MWU(data = df_hla_nk_expression, stage = "III", msi = "MSI", hla_var = "HLA_E_cat", nk_var = "NCR1", title_prefix = "StageIII")
bp50 <- boxplot_MWU(data = df_hla_nk_expression, stage = "III", msi = "MSS", hla_var = "HLA_E_cat", nk_var = "NCR1", title_prefix = "StageIII")

# Visualizar los gráficos en un grid 2x2
bp47 + bp48 + bp49 + bp50 + plot_layout(ncol = 2, nrow = 2)
```

Nos da significación en los casos StageII, MSS y StageIII, MSS. 

### MSS Estadio II/III HLA-E 

```{r chunck_HLA_11, fig.width=10, fig.height=10, echo=TRUE}
# Seleccionamos estadio tipo II ya lo hemos hecho antes
df_hla_nk_expression_MSS <- sqldf('SELECT * FROM df_hla_nk_expression WHERE msi_imputed = "MSS"')

# Creamos el gráfico de dispersión para Estadio II
pd4 <- ggplot(df_hla_nk_expression_MSS, aes(x = `HLA-E`, y = NCR1)) +
  geom_point(aes(color = stage, shape = stage), size = 3, stroke = 1) +
  labs(title = "MSS",
       x = "HLA-E",
       y = "NKP46 (NCR1)",
       color = "II/III",
       shape = "II/III") +
  scale_shape_manual(values = c(16, 2)) +  # cuadrado lleno, triángulo
  scale_color_manual(values = c("darkorange2", "dodgerblue4")) +
  theme_classic() +
  theme(
    axis.line = element_line(color = "black"),
    legend.position = c(0.1, 0.9))

# Añadimos líneas de regresión lineal para cada grupo MSI y MSS
pd4 <- pd4 + geom_smooth(method = "lm", aes(color = stage), se = FALSE)

# Visualizamos el gráfico
pd4
```


```{r chunck_HLA_12, fig.width=10, fig.height=10, echo=TRUE}
# Ajustamos un modelo lineal para Estadio II
lmod_ser <- lm(NCR1 ~ `HLA-A`*stage, data = df_hla_nk_expression_MSS)
# Hacemos una contraste de paralelismo de rectas con anova
anova(lmod_ser)
```

El efecto principal de HLA-A en NCR1 es significativo (p = 0.004317). Esto 
significa que hay una relación significativa entre HLA-A y la infiltración de 
células NK activadas. Dado que el p-valor es menor que 0.01 (**), esto indica 
una fuerte evidencia contra la hipótesis nula de que HLA-A no tiene un efecto 
sobre NCR1.  

El efecto de stage en NCR1 no es significativo (p = 0.183005). Esto sugiere que 
no hay suficiente evidencia para concluir que el estadio tenga un efecto sobre 
NCR1 cuando se considera solo este factor.

Vemos que hay significación en la hipótesis de paralelismo `HLA-A`:stage 
(Pr: 0.965735), no son paralelas. La interacción entre HLA-A y stage no es 
significativa (p = 0.965735). Esto indica que no hay suficiente evidencia para 
concluir que el efecto de HLA-A sobre NCR1 depende del estadio de la muestra.

# Análisi HALA's con infiltración (MCPcounter) {.tabset .tabset-fade .tabset-pills}

## Boxplot HLA-A Cat vs 'NK cells'

```{r chunck_HLA_16, fig.width=10, fig.height=10, echo=TRUE}
# Generar los gráficos para cada combinación de stage, msi y HLA variable
bp51 <- boxplot_MWU(data = df_hla_nk_expression, stage = "II", msi = "MSI", hla_var = "HLA_A_cat", nk_var = "NK cells", title_prefix = "StageII")
bp52 <- boxplot_MWU(data = df_hla_nk_expression, stage = "II", msi = "MSS", hla_var = "HLA_A_cat", nk_var = "NK cells", title_prefix = "StageII")
bp53 <- boxplot_MWU(data = df_hla_nk_expression, stage = "III", msi = "MSI", hla_var = "HLA_A_cat", nk_var = "NK cells", title_prefix = "StageIII")
bp54 <- boxplot_MWU(data = df_hla_nk_expression, stage = "III", msi = "MSS", hla_var = "HLA_A_cat", nk_var = "NK cells", title_prefix = "StageIII")

# Visualizar los gráficos en un grid 2x2 (patchwork)
bp51 + bp52 + bp53 + bp54 + plot_layout(ncol = 2, nrow = 2)
```

## Boxplot HLA-B Cat vs 'NK cells'

```{r chunck_HLA_17, fig.width=10, fig.height=10, echo=TRUE}
# Generar los gráficos para cada combinación de stage, msi y HLA variable
bp55 <- boxplot_MWU(data = df_hla_nk_expression, stage = "II", msi = "MSI", hla_var = "HLA_B_cat", nk_var = "NK cells", title_prefix = "StageII")
bp56 <- boxplot_MWU(data = df_hla_nk_expression, stage = "II", msi = "MSS", hla_var = "HLA_B_cat", nk_var = "NK cells", title_prefix = "StageII")
bp57 <- boxplot_MWU(data = df_hla_nk_expression, stage = "III", msi = "MSI", hla_var = "HLA_B_cat", nk_var = "NK cells", title_prefix = "StageIII")
bp58 <- boxplot_MWU(data = df_hla_nk_expression, stage = "III", msi = "MSS", hla_var = "HLA_B_cat", nk_var = "NK cells", title_prefix = "StageIII")

# Visualizar los gráficos en un grid 2x2 (patchwork)
bp55 + bp56 + bp57 + bp58 + plot_layout(ncol = 2, nrow = 2)
```

## Boxplot HLA-C Cat vs 'NK cells'

```{r chunck_HLA_18, fig.width=10, fig.height=10, echo=TRUE}
# Generar los gráficos para cada combinación de stage, msi y HLA variable
bp59 <- boxplot_MWU(data = df_hla_nk_expression, stage = "II", msi = "MSI", hla_var = "HLA_C_cat", nk_var = "NK cells", title_prefix = "StageII")
bp60 <- boxplot_MWU(data = df_hla_nk_expression, stage = "II", msi = "MSS", hla_var = "HLA_C_cat", nk_var = "NK cells", title_prefix = "StageII")
bp61 <- boxplot_MWU(data = df_hla_nk_expression, stage = "III", msi = "MSI", hla_var = "HLA_C_cat", nk_var = "NK cells", title_prefix = "StageIII")
bp62 <- boxplot_MWU(data = df_hla_nk_expression, stage = "III", msi = "MSS", hla_var = "HLA_C_cat", nk_var = "NK cells", title_prefix = "StageIII")

# Visualizar los gráficos en un grid 2x2 (patchwork)
bp59 + bp60 + bp61 + bp62 + plot_layout(ncol = 2, nrow = 2)
```

## Boxplot HLA-E Cat vs 'NK cells'

```{r chunck_HLA_19, fig.width=10, fig.height=10, echo=TRUE}
# Generar los gráficos para cada combinación de stage, msi y HLA variable
bp63 <- boxplot_MWU(data = df_hla_nk_expression, stage = "II", msi = "MSI", hla_var = "HLA_E_cat", nk_var = "NK cells", title_prefix = "StageII")
bp64 <- boxplot_MWU(data = df_hla_nk_expression, stage = "II", msi = "MSS", hla_var = "HLA_E_cat", nk_var = "NK cells", title_prefix = "StageII")
bp65 <- boxplot_MWU(data = df_hla_nk_expression, stage = "III", msi = "MSI", hla_var = "HLA_E_cat", nk_var = "NK cells", title_prefix = "StageIII")
bp66 <- boxplot_MWU(data = df_hla_nk_expression, stage = "III", msi = "MSS", hla_var = "HLA_E_cat", nk_var = "NK cells", title_prefix = "StageIII")

# Visualizar los gráficos en un grid 2x2 (patchwork)
bp63 + bp64 + bp65 + bp66 + plot_layout(ncol = 2, nrow = 2)
```


# Algoritmo Random Forest (ML) {.tabset .tabset-fade .tabset-pills}

El algoritmo "Random Forest" es un método de aprendizaje supervisado utilizado 
para la clasificación en el campo de machine learning (ML). 
Se utilizan en una amplia gama de campos como, por ejemplo, en el diagnóstico médico.  
Aplicaremos este algoritmo a nuestros datos para clasificar los CRC así como el 
estadio de los mismos.

```{r chunck_ML_función}
# library(randomForest)
# library(caret)
# library(dplyr)

# Función para crear y evaluar un modelo Random Forest con 100 árboles
run_randomForest_model <- function(data, target_name = 'class', p_train = 0.67, 
                                   seed = 12357, ntree = 100) {
  set.seed(seed)
  
  # Preparamos los datos
  clean_data <- na.omit(data)
  # Obtenemos el número total de filas (datos)
  # n <- nrow(clean_data)
  # Obtenemos los índices de filas al azar para entrenamiento
  # indices_train <- sample(1:n, round(p_train * n))
  
  # Usar createDataPartition para obtener índices de entrenamiento
  indices_train <- createDataPartition(y = clean_data$class, p = params$p.train, list = FALSE)

  # Seleccionamos las filas para entrenamiento
  data_train <- clean_data[indices_train, ]
  # Seleccionamos las filas restantes para pruebas
  data_test <- clean_data[-indices_train, ]
  # Creamos los labels de class de "train"
  train_labels <- data_train[[target_name]]
  # Creamos los labels de class de "test"
  test_labels <- data_test[[target_name]]
  
  # Creamos el modelo
  model <- randomForest(data_train[-1], train_labels, ntree = ntree)
  
  # Predicción y evaluación
  predictions <- predict(model, data_test[-1], type = "response")
  results <- confusionMatrix(table(predictions, test_labels))
  
  return(list(model = model, results = results))
}
```
  
## Estadio

```{r chunck_ML_stage}
# Añadimos la variable "class" que queramos para los modelos ML
df_exmat_stage <- cbind(df_dataClin['stage'], df_exmat_t)
# Cambiamos el nombre de la primera columna a 'class'
names(df_exmat_stage)[1] <- "class"
# Ejecutamos el modelo Random Forest
model_results <- run_randomForest_model(df_exmat_stage)

# Vemos la información del modelo
model_results$model
# Vemos el summary del modelo
# summary(model_results$model)
# Vemos los resultados de la Matriz de Confusión de las predicciones (test)
print(model_results$results)

# Regogemos los datos para comparar de la predicción 
stage_Accuracy <- model_results$results$overall["Accuracy"]
stage_Kappa <- model_results$results$overall["Kappa"]
stage_AccuracyLower <- model_results$results$overall["AccuracyLower"]
stage_AccuracyUpper <- model_results$results$overall["AccuracyUpper"]
```

## MSI/MSS

```{r chunck_ML_msi}
# Añadimos la variable "class" que queramos para los modelos ML
df_exmat_msi <- cbind(df_dataClin['msi_imputed'], df_exmat_t)
# Cambiamos el nombre de la primera columna a 'class'
names(df_exmat_msi)[1] <- "class"
# Ejecutamos el modelo Random Forest
model_results <- run_randomForest_model(df_exmat_msi, ntree = 200)

# Vemos la información del modelo
model_results$model
# Vemos el summary del modelo
# summary(model_results$model)
# Vemos los resultados de la Matriz de Confusión de las predicciones (test)
print(model_results$results)

# Regogemos los datos para comparar de la predicción 
msi_Accuracy <- model_results$results$overall["Accuracy"]
msi_Kappa <- model_results$results$overall["Kappa"]
msi_AccuracyLower <- model_results$results$overall["AccuracyLower"]
msi_AccuracyUpper <- model_results$results$overall["AccuracyUpper"]
```

## MSI/MSS-Estadio

```{r chunck_ML_msi_mss_stage}
# Añadimos la variable "class" que queramos para los modelos ML
df_exmat_msi_stage <- cbind(df_dataClin['grupo'], df_exmat_t)
# Cambiamos el nombre de la primera columna a 'class'
names(df_exmat_msi_stage)[1] <- "class"
# Ejecutamos el modelo Random Forest
model_results <- run_randomForest_model(df_exmat_msi_stage, ntree = 200)

# Vemos la información del modelo
model_results$model
# Vemos el summary del modelo
# summary(model_results$model)
# Vemos los resultados de la Matriz de Confusión de las predicciones (test)
print(model_results$results)

# Regogemos los datos para comparar de la predicción 
msi_mss_stage_Accuracy <- model_results$results$overall["Accuracy"]
msi_mss_stage_Kappa <- model_results$results$overall["Kappa"]
msi_mss_stage_AccuracyLower <- model_results$results$overall["AccuracyLower"]
msi_mss_stage_AccuracyUpper <- model_results$results$overall["AccuracyUpper"]
```

## CMS

```{r chunck_ML_cms}
# Añadimos la variable "class" que queramos para los modelos ML
df_exmat_cms <- cbind(df_dataClin['cms'], df_exmat_t)
# Cambiamos el nombre de la primera columna a 'class'
names(df_exmat_cms)[1] <- "class"
# Ejecutamos el modelo Random Forest
model_results <- run_randomForest_model(df_exmat_cms)

# Vemos la información del modelo
model_results$model
# Vemos el summary del modelo
# summary(model_results$model)
# Vemos los resultados de la Matriz de Confusión de las predicciones (test)
print(model_results$results)

# Regogemos los datos para comparar de la predicción 
cms_Accuracy <- model_results$results$overall["Accuracy"]
cms_Kappa <- model_results$results$overall["Kappa"]
cms_AccuracyLower <- model_results$results$overall["AccuracyLower"]
cms_AccuracyUpper <- model_results$results$overall["AccuracyUpper"]
```
  
## CMS-Estadio

```{r chunck_ML_cms_stage}
# Añadimos la variable "class" que queramos para los modelos ML
df_exmat_cms_stage <- cbind(df_dataClin['cms_stage'], df_exmat_t)
# Cambiamos el nombre de la primera columna a 'class'
names(df_exmat_cms_stage)[1] <- "class"
# Ejecutamos el modelo Random Forest
model_results <- run_randomForest_model(df_exmat_cms_stage, ntree = 200)

# Vemos la información del modelo
model_results$model
# Vemos el summary del modelo
# summary(model_results$model)
# Vemos los resultados de la Matriz de Confusión de las predicciones (test)
print(model_results$results)

# Regogemos los datos para comparar de la predicción 
cms_stage_Accuracy <- model_results$results$overall["Accuracy"]
cms_stage_Kappa <- model_results$results$overall["Kappa"]
cms_stage_AccuracyLower <- model_results$results$overall["AccuracyLower"]
cms_stage_AccuracyUpper <- model_results$results$overall["AccuracyUpper"]
```  
  
## MSI-Estadio

```{r chunck_ML_msi_stage}
# Filtramos y escogemos solo los datos msi_imputed = MSI
df_dataClin_exmat_msi <- df_dataClin_exmat_t[df_dataClin_exmat_t$msi_imputed == "MSI", ]
# Nos quedamos solo con la columna 'stage' como clase por lo que eliminamos las
# columnas de los datos clínicos que no nos interesan.
df_exmat_msi_stage <- df_dataClin_exmat_msi %>%
  select(-ID, -msi_imputed, -cms, -grupo, -cms_stage, -study)
# Cambiamos el nombre de la primera columna a 'class'
names(df_exmat_msi_stage)[1] <- "class"
# Ejecutamos el modelo Random Forest
model_results <- run_randomForest_model(df_exmat_msi_stage)

# Vemos la información del modelo
model_results$model
# Vemos el summary del modelo
# summary(model_results$model)
# Vemos los resultados de la Matriz de Confusión de las predicciones (test)
print(model_results$results)

# Regogemos los datos para comparar de la predicción 
msi_stage_Accuracy <- model_results$results$overall["Accuracy"]
msi_stage_Kappa <- model_results$results$overall["Kappa"]
msi_stage_AccuracyLower <- model_results$results$overall["AccuracyLower"]
msi_stage_AccuracyUpper <- model_results$results$overall["AccuracyUpper"]
```

## MSS-Estadio

```{r chunck_ML_mss_stage}
# Filtramos y escogemos solo los datos msi_imputed = MSS
df_dataClin_exmat_mss <- df_dataClin_exmat_t[df_dataClin_exmat_t$msi_imputed == "MSS", ]
# Nos quedamos solo con la columna 'stage' como clase por lo que eliminamos las
# columnas de los datos clínicos que no nos interesan.
df_exmat_mss_stage <- df_dataClin_exmat_mss %>%
  select(-ID, -msi_imputed, -cms, -grupo, -cms_stage, -study)
# Cambiamos el nombre de la primera columna a 'class'
names(df_exmat_mss_stage)[1] <- "class"
# Ejecutamos el modelo Random Forest
model_results <- run_randomForest_model(df_exmat_mss_stage)

# Vemos la información del modelo
model_results$model
# Vemos el summary del modelo
# summary(model_results$model)
# Vemos los resultados de la Matriz de Confusión de las predicciones (test)
print(model_results$results)

# Regogemos los datos para comparar de la predicción 
mss_stage_Accuracy <- model_results$results$overall["Accuracy"]
mss_stage_Kappa <- model_results$results$overall["Kappa"]
mss_stage_AccuracyLower <- model_results$results$overall["AccuracyLower"]
mss_stage_AccuracyUpper <- model_results$results$overall["AccuracyUpper"]
```

## CMS1-Estadio

```{r chunck_ML_cms1_stage}
# Filtramos y escogemos solo los datos msi_imputed = MSS
df_dataClin_exmat_cms1 <- df_dataClin_exmat_t[df_dataClin_exmat_t$cms == "CMS1", ]
# Nos quedamos solo con la columna 'stage' como clase por lo que eliminamos las
# columnas de los datos clínicos que no nos interesan.
df_exmat_cms1_stage <- df_dataClin_exmat_cms1 %>%
  select(-ID, -msi_imputed, -cms, -grupo, -cms_stage, -study)
# Cambiamos el nombre de la primera columna a 'class'
names(df_exmat_cms1_stage)[1] <- "class"
# Ejecutamos el modelo Random Forest
model_results <- run_randomForest_model(df_exmat_cms1_stage)

# Vemos la información del modelo
model_results$model
# Vemos el summary del modelo
# summary(model_results$model)
# Vemos los resultados de la Matriz de Confusión de las predicciones (test)
print(model_results$results)

# Regogemos los datos para comparar de la predicción 
cms1_stage_Accuracy <- model_results$results$overall["Accuracy"]
cms1_stage_Kappa <- model_results$results$overall["Kappa"]
cms1_stage_AccuracyLower <- model_results$results$overall["AccuracyLower"]
cms1_stage_AccuracyUpper <- model_results$results$overall["AccuracyUpper"]
```

## CMS2-Estadio

```{r chunck_ML_cms2_stage}
# Filtramos y escogemos solo los datos msi_imputed = MSS
df_dataClin_exmat_cms2 <- df_dataClin_exmat_t[df_dataClin_exmat_t$cms == "CMS2", ]
# Nos quedamos solo con la columna 'stage' como clase por lo que eliminamos las
# columnas de los datos clínicos que no nos interesan.
df_exmat_cms2_stage <- df_dataClin_exmat_cms2 %>%
  select(-ID, -msi_imputed, -cms, -grupo, -cms_stage, -study)
# Cambiamos el nombre de la primera columna a 'class'
names(df_exmat_cms2_stage)[1] <- "class"
# Ejecutamos el modelo Random Forest
model_results <- run_randomForest_model(df_exmat_cms2_stage)

# Vemos la información del modelo
model_results$model
# Vemos el summary del modelo
# summary(model_results$model)
# Vemos los resultados de la Matriz de Confusión de las predicciones (test)
print(model_results$results)

# Regogemos los datos para comparar de la predicción 
cms2_stage_Accuracy <- model_results$results$overall["Accuracy"]
cms2_stage_Kappa <- model_results$results$overall["Kappa"]
cms2_stage_AccuracyLower <- model_results$results$overall["AccuracyLower"]
cms2_stage_AccuracyUpper <- model_results$results$overall["AccuracyUpper"]
```

## CMS3-Estadio

```{r chunck_ML_cms3_stage}
# Filtramos y escogemos solo los datos msi_imputed = MSS
df_dataClin_exmat_cms3 <- df_dataClin_exmat_t[df_dataClin_exmat_t$cms == "CMS3", ]
# Nos quedamos solo con la columna 'stage' como clase por lo que eliminamos las
# columnas de los datos clínicos que no nos interesan.
df_exmat_cms3_stage <- df_dataClin_exmat_cms3 %>%
  select(-ID, -msi_imputed, -cms, -grupo, -cms_stage, -study)
# Cambiamos el nombre de la primera columna a 'class'
names(df_exmat_cms3_stage)[1] <- "class"
# Ejecutamos el modelo Random Forest
model_results <- run_randomForest_model(df_exmat_cms3_stage)

# Vemos la información del modelo
model_results$model
# Vemos el summary del modelo
# summary(model_results$model)
# Vemos los resultados de la Matriz de Confusión de las predicciones (test)
print(model_results$results)

# Regogemos los datos para comparar de la predicción 
cms3_stage_Accuracy <- model_results$results$overall["Accuracy"]
cms3_stage_Kappa <- model_results$results$overall["Kappa"]
cms3_stage_AccuracyLower <- model_results$results$overall["AccuracyLower"]
cms3_stage_AccuracyUpper <- model_results$results$overall["AccuracyUpper"]
```

## CMS4-Estadio

```{r chunck_ML_cms4_stage}
# Filtramos y escogemos solo los datos msi_imputed = MSS
df_dataClin_exmat_cms4 <- df_dataClin_exmat_t[df_dataClin_exmat_t$cms == "CMS4", ]
# Nos quedamos solo con la columna 'stage' como clase por lo que eliminamos las
# columnas de los datos clínicos que no nos interesan.
df_exmat_cms4_stage <- df_dataClin_exmat_cms4 %>%
  select(-ID, -msi_imputed, -cms, -grupo, -cms_stage, -study)
# Cambiamos el nombre de la primera columna a 'class'
names(df_exmat_cms4_stage)[1] <- "class"
# Ejecutamos el modelo Random Forest
model_results <- run_randomForest_model(df_exmat_cms4_stage)

# Vemos la información del modelo
model_results$model
# Vemos el summary del modelo
# summary(model_results$model)
# Vemos los resultados de la Matriz de Confusión de las predicciones (test)
print(model_results$results)

# Regogemos los datos para comparar de la predicción 
cms4_stage_Accuracy <- model_results$results$overall["Accuracy"]
cms4_stage_Kappa <- model_results$results$overall["Kappa"]
cms4_stage_AccuracyLower <- model_results$results$overall["AccuracyLower"]
cms4_stage_AccuracyUpper <- model_results$results$overall["AccuracyUpper"]
```


## Resultados  

Modelo|Accuraccy|kappa|95% CI
:----|:----|:----:|:----:
Estadio|`r stage_Accuracy`|`r stage_Kappa`|(`r stage_AccuracyLower` - `r stage_AccuracyUpper`)
MSI/MSS|`r msi_Accuracy`|`r msi_Kappa`|(`r msi_AccuracyLower` - `r msi_AccuracyUpper`)
MSI/MSS-Estadio|`r msi_mss_stage_Accuracy`|`r msi_mss_stage_Kappa`|(`r msi_mss_stage_AccuracyLower` - `r msi_mss_stage_AccuracyUpper`)
CMS|`r cms_Accuracy`|`r cms_Kappa`|(`r cms_AccuracyLower` - `r cms_AccuracyUpper`)
CMS-Estadio|`r cms_stage_Accuracy`|`r cms_stage_Kappa`|(`r cms_stage_AccuracyLower` - `r cms_stage_AccuracyUpper`)
MSI-Estadio|`r msi_stage_Accuracy`|`r msi_stage_Kappa`|(`r msi_stage_AccuracyLower` - `r msi_stage_AccuracyUpper`)
MSS-Estadio|`r mss_stage_Accuracy`|`r mss_stage_Kappa`|(`r mss_stage_AccuracyLower` - `r mss_stage_AccuracyUpper`)
CMS1-Estadio|`r cms1_stage_Accuracy`|`r cms1_stage_Kappa`|(`r cms1_stage_AccuracyLower` - `r cms1_stage_AccuracyUpper`)
CMS2-Estadio|`r cms2_stage_Accuracy`|`r cms2_stage_Kappa`|(`r cms2_stage_AccuracyLower` - `r cms2_stage_AccuracyUpper`)
CMS3-Estadio|`r cms3_stage_Accuracy`|`r cms3_stage_Kappa`|(`r cms3_stage_AccuracyLower` - `r cms3_stage_AccuracyUpper`)
CMS4-Estadio|`r cms4_stage_Accuracy`|`r cms4_stage_Kappa`|(`r cms4_stage_AccuracyLower` - `r cms4_stage_AccuracyUpper`)


# ML con los genes MCPcounter {.tabset .tabset-fade .tabset-pills}

Utilizamos de nuevo el algoritmo "Random Forest" para clasificar los CRC pro en este caso utiizaremos solamente los genes que utiliza MCPcounter para caracterizar la infiltración celular inmunitaria.

```{r chunck_ML_MCPc}
# 25/06/2024
# Conjunto de genes usados por MCPcounter
genes_MCPc <- c("CD28", "CD3D", "CD5", "TRAT1", "CD8B", "CD8A", "EOMES", "GNLY", 
                   "KLRK1", "KIR2DL3", "KIR2DL4", "KIR3DS1", "NCR1", "CD19", 
                   "CD79A", "CD79B", "MS4A1", "ADAP2", "CSF1R", "RASSF4", "TFEC", 
                   "CD1A", "CD1B", "CD1E", "CLEC10A", "CEACAM3", "CXCR1", "CXCR2", 
                   "FCGR3B", "CDH5", "MMRN1", "MMRN2", "VWF", "COL1A1", "COL6A2")

# Comprobamos si están en nuestro data frame

genes_MCPc_presentes <- genes_MCPc %in% colnames(df_exmat_t)
genes_MCPc_faltantes <- genes_MCPc[!genes_MCPc_presentes]

#Escogemos el data frame con los genes presentes
df_exmat_t_MCPc <- df_exmat_t[ , colnames(df_exmat_t) %in% genes_MCPc]
```
  
## Estadio

```{r chunck_ML_MCPc_stage}
# Añadimos la variable "class" que queramos para los modelos ML
df_exmat_stage_MCPc <- cbind(df_dataClin['stage'], df_exmat_t_MCPc)
# Cambiamos el nombre de la primera columna a 'class'
names(df_exmat_stage_MCPc)[1] <- "class"
# Ejecutamos el modelo Random Forest
model_results <- run_randomForest_model(df_exmat_stage_MCPc)

# Vemos la información del modelo
model_results$model
# Vemos el summary del modelo
# summary(model_results$model)
# Vemos los resultados de la Matriz de Confusión de las predicciones (test)
print(model_results$results)

# Regogemos los datos para comparar de la predicción 
stage_Accuracy_MCPc <- model_results$results$overall["Accuracy"]
stage_Kappa_MCPc <- model_results$results$overall["Kappa"]
stage_AccuracyLower_MCPc <- model_results$results$overall["AccuracyLower"]
stage_AccuracyUpper_MCPc <- model_results$results$overall["AccuracyUpper"]
```

## MSI/MSS

```{r chunck_ML_MCPc_msi}
# Añadimos la variable "class" que queramos para los modelos ML
df_exmat_msi_MCPc <- cbind(df_dataClin['msi_imputed'], df_exmat_t_MCPc)
# Cambiamos el nombre de la primera columna a 'class'
names(df_exmat_msi_MCPc)[1] <- "class"
# Ejecutamos el modelo Random Forest
model_results <- run_randomForest_model(df_exmat_msi_MCPc, ntree = 200)

# Vemos la información del modelo
model_results$model
# Vemos el summary del modelo
# summary(model_results$model)
# Vemos los resultados de la Matriz de Confusión de las predicciones (test)
print(model_results$results)

# Regogemos los datos para comparar de la predicción 
msi_Accuracy_MCPc <- model_results$results$overall["Accuracy"]
msi_Kappa_MCPc <- model_results$results$overall["Kappa"]
msi_AccuracyLower_MCPc <- model_results$results$overall["AccuracyLower"]
msi_AccuracyUpper_MCPc <- model_results$results$overall["AccuracyUpper"]
```

## MSI/MSS-Estadio

```{r chunck_ML_MCPc_msi_mss_stage}
# Añadimos la variable "class" que queramos para los modelos ML
df_exmat_msi_stage_MCPc <- cbind(df_dataClin['grupo'], df_exmat_t_MCPc)
# Cambiamos el nombre de la primera columna a 'class'
names(df_exmat_msi_stage_MCPc)[1] <- "class"
# Ejecutamos el modelo Random Forest
model_results <- run_randomForest_model(df_exmat_msi_stage_MCPc, ntree = 200)

# Vemos la información del modelo
model_results$model
# Vemos el summary del modelo
# summary(model_results$model)
# Vemos los resultados de la Matriz de Confusión de las predicciones (test)
print(model_results$results)

# Regogemos los datos para comparar de la predicción 
msi_mss_stage_Accuracy_MCPc <- model_results$results$overall["Accuracy"]
msi_mss_stage_Kappa_MCPc <- model_results$results$overall["Kappa"]
msi_mss_stage_AccuracyLower_MCPc <- model_results$results$overall["AccuracyLower"]
msi_mss_stage_AccuracyUpper_MCPc <- model_results$results$overall["AccuracyUpper"]
```

## CMS

```{r chunck_ML_MCPc_cms}
# Añadimos la variable "class" que queramos para los modelos ML
df_exmat_cms_MCPc <- cbind(df_dataClin['cms'], df_exmat_t_MCPc)
# Cambiamos el nombre de la primera columna a 'class'
names(df_exmat_cms_MCPc)[1] <- "class"
# Ejecutamos el modelo Random Forest
model_results <- run_randomForest_model(df_exmat_cms_MCPc)

# Vemos la información del modelo
model_results$model
# Vemos el summary del modelo
# summary(model_results$model)
# Vemos los resultados de la Matriz de Confusión de las predicciones (test)
print(model_results$results)

# Regogemos los datos para comparar de la predicción 
cms_Accuracy_MCPc <- model_results$results$overall["Accuracy"]
cms_Kappa_MCPc <- model_results$results$overall["Kappa"]
cms_AccuracyLower_MCPc <- model_results$results$overall["AccuracyLower"]
cms_AccuracyUpper_MCPc <- model_results$results$overall["AccuracyUpper"]
```

## Resultados ML con genes MCPc 

Modelo|Accuraccy|kappa|95% CI
:----|:----|:----:|:----:
Estadio|`r stage_Accuracy_MCPc`|`r stage_Kappa_MCPc`|(`r stage_AccuracyLower_MCPc` - `r stage_AccuracyUpper_MCPc`)
MSI/MSS|`r msi_Accuracy_MCPc`|`r msi_Kappa_MCPc`|(`r msi_AccuracyLower_MCPc` - `r msi_AccuracyUpper_MCPc`)
MSI/MSS-Estadio|`r msi_mss_stage_Accuracy_MCPc`|`r msi_mss_stage_Kappa_MCPc`|(`r msi_mss_stage_AccuracyLower_MCPc` - `r msi_mss_stage_AccuracyUpper_MCPc`)
CMS|`r cms_Accuracy_MCPc`|`r cms_Kappa_MCPc`|(`r cms_AccuracyLower_MCPc` - `r cms_AccuracyUpper_MCPc`)


# ML con los genes PCA {.tabset .tabset-fade .tabset-pills}

Utilizamos de nuevo el algoritmo "Random Forest" para clasificar los CRC pero en este caso usando solo los 10 genes con más peso que utiliza la PCA para su primer y segundo componentes PC1 y PC2.

PC1: "SFRP2", "GAS1", "COL10A1", "CCL18", "CYP1B1", "SPP1", "GPNMB", "GREM1", "CCDC80", "POSTN"
  
PC2: "REG4", "ZIC2", "REG1A", "TRIM7", "CTSE", "TCN1", "AGR3", "RAB27B", "SDR16C5", "PLA2G2A"


```{r chunck_ML_PCA}
# 29/06/2024
# Conjunto de genes usados por PCAounter
genes_PCA <- c("SFRP2", "GAS1", "COL10A1", "CCL18", "CYP1B1", "SPP1", "GPNMB", "GREM1", "CCDC80", "POSTN", 
                   "REG4", "ZIC2", "REG1A", "TRIM7", "CTSE", "TCN1", "AGR3", "RAB27B", "SDR16C5", "PLA2G2A")

# Comprobamos si están en nuestro data frame

genes_PCA_presentes <- genes_PCA %in% colnames(df_exmat_t)
genes_PCA_faltantes <- genes_PCA[!genes_PCA_presentes]

#Escogemos el data frame con los genes presentes
df_exmat_t_PCA <- df_exmat_t[ , colnames(df_exmat_t) %in% genes_PCA]
```
  
## Estadio

```{r chunck_ML_PCA_stage}
# Añadimos la variable "class" que queramos para los modelos ML
df_exmat_stage_PCA <- cbind(df_dataClin['stage'], df_exmat_t_PCA)
# Cambiamos el nombre de la primera columna a 'class'
names(df_exmat_stage_PCA)[1] <- "class"
# Ejecutamos el modelo Random Forest
model_results <- run_randomForest_model(df_exmat_stage_PCA)

# Vemos la información del modelo
model_results$model
# Vemos el summary del modelo
# summary(model_results$model)
# Vemos los resultados de la Matriz de Confusión de las predicciones (test)
print(model_results$results)

# Regogemos los datos para comparar de la predicción 
stage_Accuracy_PCA <- model_results$results$overall["Accuracy"]
stage_Kappa_PCA <- model_results$results$overall["Kappa"]
stage_AccuracyLower_PCA <- model_results$results$overall["AccuracyLower"]
stage_AccuracyUpper_PCA <- model_results$results$overall["AccuracyUpper"]
```

## MSI/MSS

```{r chunck_ML_PCA_msi}
# Añadimos la variable "class" que queramos para los modelos ML
df_exmat_msi_PCA <- cbind(df_dataClin['msi_imputed'], df_exmat_t_PCA)
# Cambiamos el nombre de la primera columna a 'class'
names(df_exmat_msi_PCA)[1] <- "class"
# Ejecutamos el modelo Random Forest
model_results <- run_randomForest_model(df_exmat_msi_PCA, ntree = 200)

# Vemos la información del modelo
model_results$model
# Vemos el summary del modelo
# summary(model_results$model)
# Vemos los resultados de la Matriz de Confusión de las predicciones (test)
print(model_results$results)

# Regogemos los datos para comparar de la predicción 
msi_Accuracy_PCA <- model_results$results$overall["Accuracy"]
msi_Kappa_PCA <- model_results$results$overall["Kappa"]
msi_AccuracyLower_PCA <- model_results$results$overall["AccuracyLower"]
msi_AccuracyUpper_PCA <- model_results$results$overall["AccuracyUpper"]
```

## MSI/MSS-Estadio

```{r chunck_ML_PCA_msi_mss_stage}
# Añadimos la variable "class" que queramos para los modelos ML
df_exmat_msi_stage_PCA <- cbind(df_dataClin['grupo'], df_exmat_t_PCA)
# Cambiamos el nombre de la primera columna a 'class'
names(df_exmat_msi_stage_PCA)[1] <- "class"
# Ejecutamos el modelo Random Forest
model_results <- run_randomForest_model(df_exmat_msi_stage_PCA, ntree = 200)

# Vemos la información del modelo
model_results$model
# Vemos el summary del modelo
# summary(model_results$model)
# Vemos los resultados de la Matriz de Confusión de las predicciones (test)
print(model_results$results)

# Regogemos los datos para comparar de la predicción 
msi_mss_stage_Accuracy_PCA <- model_results$results$overall["Accuracy"]
msi_mss_stage_Kappa_PCA <- model_results$results$overall["Kappa"]
msi_mss_stage_AccuracyLower_PCA <- model_results$results$overall["AccuracyLower"]
msi_mss_stage_AccuracyUpper_PCA <- model_results$results$overall["AccuracyUpper"]
```

## CMS

```{r chunck_ML_PCA_cms}
# Añadimos la variable "class" que queramos para los modelos ML
df_exmat_cms_PCA <- cbind(df_dataClin['cms'], df_exmat_t_PCA)
# Cambiamos el nombre de la primera columna a 'class'
names(df_exmat_cms_PCA)[1] <- "class"
# Ejecutamos el modelo Random Forest
model_results <- run_randomForest_model(df_exmat_cms_PCA)

# Vemos la información del modelo
model_results$model
# Vemos el summary del modelo
# summary(model_results$model)
# Vemos los resultados de la Matriz de Confusión de las predicciones (test)
print(model_results$results)

# Regogemos los datos para comparar de la predicción 
cms_Accuracy_PCA <- model_results$results$overall["Accuracy"]
cms_Kappa_PCA <- model_results$results$overall["Kappa"]
cms_AccuracyLower_PCA <- model_results$results$overall["AccuracyLower"]
cms_AccuracyUpper_PCA <- model_results$results$overall["AccuracyUpper"]
```

## Resultados ML con genes PCA 

Modelo|Accuraccy|kappa|95% CI
:----|:----|:----:|:----:
Estadio|`r stage_Accuracy_PCA`|`r stage_Kappa_PCA`|(`r stage_AccuracyLower_PCA` - `r stage_AccuracyUpper_PCA`)
MSI/MSS|`r msi_Accuracy_PCA`|`r msi_Kappa_PCA`|(`r msi_AccuracyLower_PCA` - `r msi_AccuracyUpper_PCA`)
MSI/MSS-Estadio|`r msi_mss_stage_Accuracy_PCA`|`r msi_mss_stage_Kappa_PCA`|(`r msi_mss_stage_AccuracyLower_PCA` - `r msi_mss_stage_AccuracyUpper_PCA`)
CMS|`r cms_Accuracy_PCA`|`r cms_Kappa_PCA`|(`r cms_AccuracyLower_PCA` - `r cms_AccuracyUpper_PCA`)


# ML con los genes MMR (MSI/MSS) {.tabset .tabset-fade .tabset-pills}

Utilizamos de nuevo el algoritmo "Random Forest" para clasificar los CRC pero en este caso usando solo los genes implicados en Inestabilidad de Microsatélites.

Genes implicados en MSI (Inestabilidad de Microsatélites)

MSI se caracteriza por defectos en el sistema de reparación de errores de emparejamiento del ADN (MMR, por sus siglas en inglés). Los genes implicados en MSI incluyen:

    MLH1 (MutL Homolog 1)
    MSH2 (MutS Homolog 2)
    MSH6 (MutS Homolog 6)
    PMS2 (Postmeiotic Segregation Increased 2)
    EPCAM (Epithelial Cell Adhesion Molecule) - aunque no es un gen MMR, su inactivación puede afectar la expresión de MSH2.

Otros genes y factores implicados en cáncer colorrectal MSI y MSS

Además de los genes MMR, hay otros genes y vías que pueden estar implicados en el cáncer colorrectal, tanto en MSI como en MSS:

    BRAF: Mutaciones en BRAF son comunes en tumores MSI.
    KRAS: Mutaciones en KRAS pueden ocurrir en ambos tipos de tumores.
    PIK3CA: Mutaciones en este gen también pueden ser observadas en ambos tipos de tumores.
    TP53: Mutaciones en TP53 son más comunes en MSS.    

```{r chunck_ML_MMR}
# 25/06/2024
# Conjunto de genes usados por MMR + BRAF y TP53
genes_MMR <- c("MLH1", "MSH2", "MSH6", "PMS2", "EPCAM", "MSH2", "BRAF", "TP53")

# Comprobamos si están en nuestro data frame

genes_MMR_presentes <- genes_MMR %in% colnames(df_exmat_t)
genes_MMR_faltantes <- genes_MMR[!genes_MMR_presentes]

#Escogemos el data frame con los genes presentes
df_exmat_t_MMR <- df_exmat_t[ , colnames(df_exmat_t) %in% genes_MMR]
```
  
## Estadio

```{r chunck_ML_MMR_stage}
# Añadimos la variable "class" que queramos para los modelos ML
df_exmat_stage_MMR <- cbind(df_dataClin['stage'], df_exmat_t_MMR)
# Cambiamos el nombre de la primera columna a 'class'
names(df_exmat_stage_MMR)[1] <- "class"
# Ejecutamos el modelo Random Forest
model_results <- run_randomForest_model(df_exmat_stage_MMR)

# Vemos la información del modelo
model_results$model
# Vemos el summary del modelo
# summary(model_results$model)
# Vemos los resultados de la Matriz de Confusión de las predicciones (test)
print(model_results$results)

# Regogemos los datos para comparar de la predicción 
stage_Accuracy_MMR <- model_results$results$overall["Accuracy"]
stage_Kappa_MMR <- model_results$results$overall["Kappa"]
stage_AccuracyLower_MMR <- model_results$results$overall["AccuracyLower"]
stage_AccuracyUpper_MMR <- model_results$results$overall["AccuracyUpper"]
```

## MSI/MSS

```{r chunck_ML_MMR_msi}
# Añadimos la variable "class" que queramos para los modelos ML
df_exmat_msi_MMR <- cbind(df_dataClin['msi_imputed'], df_exmat_t_MMR)
# Cambiamos el nombre de la primera columna a 'class'
names(df_exmat_msi_MMR)[1] <- "class"
# Ejecutamos el modelo Random Forest
model_results <- run_randomForest_model(df_exmat_msi_MMR, ntree = 200)

# Vemos la información del modelo
model_results$model
# Vemos el summary del modelo
# summary(model_results$model)
# Vemos los resultados de la Matriz de Confusión de las predicciones (test)
print(model_results$results)

# Regogemos los datos para comparar de la predicción 
msi_Accuracy_MMR <- model_results$results$overall["Accuracy"]
msi_Kappa_MMR <- model_results$results$overall["Kappa"]
msi_AccuracyLower_MMR <- model_results$results$overall["AccuracyLower"]
msi_AccuracyUpper_MMR <- model_results$results$overall["AccuracyUpper"]
```

## MSI/MSS-Estadio

```{r chunck_ML_MMR_msi_mss_stage}
# Añadimos la variable "class" que queramos para los modelos ML
df_exmat_msi_stage_MMR <- cbind(df_dataClin['grupo'], df_exmat_t_MMR)
# Cambiamos el nombre de la primera columna a 'class'
names(df_exmat_msi_stage_MMR)[1] <- "class"
# Ejecutamos el modelo Random Forest
model_results <- run_randomForest_model(df_exmat_msi_stage_MMR, ntree = 200)

# Vemos la información del modelo
model_results$model
# Vemos el summary del modelo
# summary(model_results$model)
# Vemos los resultados de la Matriz de Confusión de las predicciones (test)
print(model_results$results)

# Regogemos los datos para comparar de la predicción 
msi_mss_stage_Accuracy_MMR <- model_results$results$overall["Accuracy"]
msi_mss_stage_Kappa_MMR <- model_results$results$overall["Kappa"]
msi_mss_stage_AccuracyLower_MMR <- model_results$results$overall["AccuracyLower"]
msi_mss_stage_AccuracyUpper_MMR <- model_results$results$overall["AccuracyUpper"]
```

## CMS

```{r chunck_ML_MMR_cms}
# Añadimos la variable "class" que queramos para los modelos ML
df_exmat_cms_MMR <- cbind(df_dataClin['cms'], df_exmat_t_MMR)
# Cambiamos el nombre de la primera columna a 'class'
names(df_exmat_cms_MMR)[1] <- "class"
# Ejecutamos el modelo Random Forest
model_results <- run_randomForest_model(df_exmat_cms_MMR)

# Vemos la información del modelo
model_results$model
# Vemos el summary del modelo
# summary(model_results$model)
# Vemos los resultados de la Matriz de Confusión de las predicciones (test)
print(model_results$results)

# Regogemos los datos para comparar de la predicción 
cms_Accuracy_MMR <- model_results$results$overall["Accuracy"]
cms_Kappa_MMR <- model_results$results$overall["Kappa"]
cms_AccuracyLower_MMR <- model_results$results$overall["AccuracyLower"]
cms_AccuracyUpper_MMR <- model_results$results$overall["AccuracyUpper"]
```

## Resultados ML con genes MMR 

Modelo|Accuraccy|kappa|95% CI
:----|:----|:----:|:----:
Estadio|`r stage_Accuracy_MMR`|`r stage_Kappa_MMR`|(`r stage_AccuracyLower_MMR` - `r stage_AccuracyUpper_MMR`)
MSI/MSS|`r msi_Accuracy_MMR`|`r msi_Kappa_MMR`|(`r msi_AccuracyLower_MMR` - `r msi_AccuracyUpper_MMR`)
MSI/MSS-Estadio|`r msi_mss_stage_Accuracy_MMR`|`r msi_mss_stage_Kappa_MMR`|(`r msi_mss_stage_AccuracyLower_MMR` - `r msi_mss_stage_AccuracyUpper_MMR`)
CMS|`r cms_Accuracy_MMR`|`r cms_Kappa_MMR`|(`r cms_AccuracyLower_MMR` - `r cms_AccuracyUpper_MMR`)


# Referencias  

[Repositorio](https://github.com/Sheddad/TFM_Inmunonomica_TME_CRC): [@TFMGithub2024]
